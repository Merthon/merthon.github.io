<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>爬虫 on Merthon</title><link>https://merthon.github.io/tags/%E7%88%AC%E8%99%AB/</link><description>Recent content in 爬虫 on Merthon</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 11 Feb 2025 21:59:09 +0800</lastBuildDate><atom:link href="https://merthon.github.io/tags/%E7%88%AC%E8%99%AB/index.xml" rel="self" type="application/rss+xml"/><item><title>Python构建小红书用户动态监控系统</title><link>https://merthon.github.io/posts/python%E6%9E%84%E5%BB%BA%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%94%A8%E6%88%B7%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</link><pubDate>Tue, 11 Feb 2025 21:59:09 +0800</pubDate><guid>https://merthon.github.io/posts/python%E6%9E%84%E5%BB%BA%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%94%A8%E6%88%B7%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h1 id="项目说明">项目说明&lt;/h1>
&lt;p>该项目的目的是监控小红书用户的动态笔记，自动进行点赞和评论互动。通过配置灵活的参数，可以对不同的用户进行实时互动，同时利用大语言模型（LLM）生成个性化的高情商评论。该项目主要面向开发者，帮助他们实现自动化的社交互动，提高用户参与度和互动效果。&lt;/p>
&lt;h1 id="文件结构">文件结构&lt;/h1>
&lt;p>本项目主要包含以下几个文件：
comment_generator.py：生成评论的模块。
config.py：配置文件，存储项目运行时的配置项。
db.py：数据库操作文件，负责笔记历史数据的存储与读取。
monitor.py：主程序文件，负责监控和执行互动操作。
wecom.py：与企业微信接口对接的模块，发送通知消息。
utils.py：工具模块，提供一些辅助功能。&lt;/p>
&lt;h1 id="代码和功能详情">代码和功能详情&lt;/h1>
&lt;h2 id="配置文件configpy">配置文件config.py&lt;/h2>
&lt;p>该文件包含项目的配置信息，包括监控行为、LLM 配置等&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 配置小红书，企业微信通知以及监控相关信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 小红书config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>XHS_CONFIG &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;COOKIE&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;登录后小红书的cookie&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这里使用企业微信 Webhook&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 机器人 Webhook 是最简单的方法，无需 API 认证，也没有 IP 限制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WECOM_CONFIG &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;WEBHOOK_URL&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;自己获取的Webhook URL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MONITOR_CONFIG &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;USER_ID_1&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;被监控用户的小红书id&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;USER_ID_2&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;被监控用户的小红书id&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;USER_ID_3&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;被监控用户的小红书id&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;USER_ID_4&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;被监控用户的小红书id&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;USER_ID_5&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;被监控用户的小红书id&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># &amp;#34;USER_ID&amp;#34;: &amp;#34;被监控用户的小红书id&amp;#34;,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;CHECK_INTERVAL&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#75715e"># 检查笔记更新时间（秒）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ERROR_COUNT&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;AUTO_INTERACT&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">True&lt;/span>, &lt;span style="color:#75715e"># 是否开启自动互动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;FALLBACK_COMMENTS&amp;#34;&lt;/span>: [ &lt;span style="color:#75715e"># 随机选择一条评论&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;太棒了！&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;喜欢这篇笔记&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;我来啦~&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;路过~&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;感谢分享&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;期待更新~&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;支持支持！&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;LIKE_DELAY&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#75715e"># 点赞延迟(秒)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;COMMENT_DELAY&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#75715e"># 评论延迟(秒)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># LLM配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LLM_CONFIG &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;API_KEY&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;OpenAI API Key&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;API_BASE&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;API代理地址&amp;#34;&lt;/span>, 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;MODEL&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;gpt-3.5-turbo&amp;#34;&lt;/span>, 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;MAX_TOKENS&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">150&lt;/span>, &lt;span style="color:#75715e"># 生成的评论最大字数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;TEMPERATURE&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0.7&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;SYSTEM_PROMPT&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;你是一个正在追求心仪女生的人，需要对她的小红书笔记进行评论。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">请根据笔记内容生成一条甜蜜、真诚但不过分的评论。评论要：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">1. 体现你在认真看她的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2. 表达适度的赞美和支持
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">3. 语气要自然、真诚
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">4. 避免过分讨好或低声下气
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">5. 根据内容类型（图文/视频）采用合适的表达
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">6. 字数控制在100字以内
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">7. 避免过于模板化的表达
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">8. 评论内容要符合小红书平台规则&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该文件包含项目的配置信息，包括监控行为、LLM 配置等。主要的配置项有：
MONITOR_CONFIG: 包含是否开启自动互动（AUTO_INTERACT）、评论延迟（COMMENT_DELAY）、点赞延迟（LIKE_DELAY）等。
LLM_CONFIG: 包含用于生成评论的大语言模型的配置，如 API_KEY、API_BASE、MODEL、TEMPERATURE 等。&lt;/p></description></item><item><title>异步爬虫</title><link>https://merthon.github.io/posts/%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/</link><pubDate>Tue, 14 Jan 2025 02:23:25 +0800</pubDate><guid>https://merthon.github.io/posts/%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/</guid><description>&lt;p>异步爬虫是通过异步编程技术来提升爬虫性能的一种方式。与传统的同步爬虫不同，异步爬虫能够在等待某些操作（如请求响应）时进行其他任务，从而避免了不必要的等待时间，提高了爬虫的效率。&lt;/p>
&lt;h1 id="同步与异步的区别">同步与异步的区别&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>同步爬虫&lt;/strong>：在执行过程中，每发出一次请求，程序会等待该请求的响应完成后才能继续执行下一个任务。由于请求-响应时间不稳定，导致整个爬虫的运行效率较低。&lt;/li>
&lt;li>&lt;strong>异步爬虫&lt;/strong>：通过非阻塞的方式发送请求。当请求发出后，程序并不会等待响应，而是继续执行其他任务。只有当响应返回时，程序才会处理相应的结果。这样能显著减少因等待请求响应而造成的空闲时间。&lt;/li>
&lt;/ul>
&lt;h1 id="异步爬虫的工作原理">异步爬虫的工作原理&lt;/h1>
&lt;p>异步爬虫的核心思想是利用事件循环（Event Loop）和协程（Coroutine）来实现非阻塞的任务调度。异步编程的主要优势是可以在同一线程中并行处理多个I/O密集型任务（如网络请求），从而大幅提高性能。
在异步爬虫中，我们通常使用 &lt;code>asyncio&lt;/code> 库（Python 3.7+）或者一些框架（如 &lt;code>Scrapy&lt;/code> 的异步爬虫功能）来管理异步请求。&lt;/p>
&lt;h4 id="使用-asyncio-和-aiohttp">使用 &lt;code>asyncio&lt;/code> 和 &lt;code>aiohttp&lt;/code>&lt;/h4>
&lt;p>&lt;code>aiohttp&lt;/code> 是一个支持异步 HTTP 请求的库，可以与 &lt;code>asyncio&lt;/code> 配合使用，进行非阻塞的网络请求。&lt;/p>
&lt;h2 id="基本实现步骤">基本实现步骤：&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>pip install aiohttp asyncio
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> aiohttp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> asyncio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 异步请求函数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(url):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> aiohttp&lt;span style="color:#f92672">.&lt;/span>ClientSession() &lt;span style="color:#66d9ef">as&lt;/span> session:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>get(url) &lt;span style="color:#66d9ef">as&lt;/span> response:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>text()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 异步爬虫主函数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;http://example.com&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> html &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> fetch(url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(html)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 运行异步爬虫&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;__main__&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> asyncio&lt;span style="color:#f92672">.&lt;/span>run(main())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>async&lt;/code> 定义异步函数，&lt;code>await&lt;/code> 用于挂起当前任务直到异步操作完成。&lt;/li>
&lt;li>&lt;code>aiohttp.ClientSession&lt;/code> 用于创建 HTTP 请求的会话，&lt;code>session.get(url)&lt;/code> 用于发送 GET 请求，&lt;code>await response.text()&lt;/code> 用于获取响应的 HTML 内容。&lt;/li>
&lt;li>&lt;code>asyncio.run(main())&lt;/code> 启动异步事件循环，执行 &lt;code>main()&lt;/code> 函数。&lt;/li>
&lt;/ul>
&lt;h2 id="并发发送多个请求">并发发送多个请求：&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> aiohttp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> asyncio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(url):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> aiohttp&lt;span style="color:#f92672">.&lt;/span>ClientSession() &lt;span style="color:#66d9ef">as&lt;/span> session:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>get(url) &lt;span style="color:#66d9ef">as&lt;/span> response:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>text()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> urls &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;http://example.com&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;http://example.org&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;http://example.net&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tasks &lt;span style="color:#f92672">=&lt;/span> [fetch(url) &lt;span style="color:#66d9ef">for&lt;/span> url &lt;span style="color:#f92672">in&lt;/span> urls]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> results &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> asyncio&lt;span style="color:#f92672">.&lt;/span>gather(&lt;span style="color:#f92672">*&lt;/span>tasks)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> result &lt;span style="color:#f92672">in&lt;/span> results:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(result)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;__main__&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> asyncio&lt;span style="color:#f92672">.&lt;/span>run(main())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>asyncio.gather(*tasks)&lt;/code> 用于并发执行多个任务，将多个异步任务打包成一个任务集合并发运行。&lt;/li>
&lt;li>&lt;code>tasks&lt;/code> 列表存储了对多个 URL 的请求任务，通过 &lt;code>await asyncio.gather(*tasks)&lt;/code> 同时启动多个请求。&lt;/li>
&lt;/ul>
&lt;h1 id="异步爬虫的优点">异步爬虫的优点&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>高效的 I/O 操作&lt;/strong>：异步爬虫能够处理大量的网络请求，而不必因为等待响应而浪费时间，极大提高了爬虫的效率。&lt;/li>
&lt;li>&lt;strong>资源占用低&lt;/strong>：相比多线程和多进程，异步爬虫的资源占用更少，可以在单线程中完成大量任务。&lt;/li>
&lt;li>&lt;strong>提高爬虫速度&lt;/strong>：尤其在抓取大量数据时，异步爬虫能够显著提高速度。&lt;/li>
&lt;/ul>
&lt;h1 id="scrapy-异步爬虫">Scrapy 异步爬虫&lt;/h1>
&lt;p>Scrapy 本身是一个异步爬虫框架，底层基于 Twisted 库，它通过事件驱动模型来处理多个请求。Scrapy 的异步功能非常强大，爬虫中的请求和回调（callback）都会自动异步执行。&lt;/p></description></item><item><title>Selenium的使用</title><link>https://merthon.github.io/posts/selenium%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 12 Jan 2025 18:23:25 +0800</pubDate><guid>https://merthon.github.io/posts/selenium%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>Selenium 是一个强大的 Web 自动化测试工具，广泛用于自动化浏览器操作。它支持多种浏览器，并可以与编程语言如 Python、Java、C# 等配合使用。&lt;/p>
&lt;h1 id="安装">安装&lt;/h1>
&lt;p>首先，你需要安装 Selenium 库。可以通过 pip 安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>pip install selenium
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="下载webdriver">下载WebDriver&lt;/h1>
&lt;p>Selenium 需要使用 WebDriver 来驱动浏览器。不同的浏览器需要不同的 WebDriver
下载对应浏览器的 WebDriver，并确保 WebDriver 可执行文件在你的系统路径中。&lt;/p>
&lt;h1 id="基本使用">基本使用&lt;/h1>
&lt;p>Selenium 的一个简单示例，展示如何使用 Python 驱动浏览器打开网页，查找元素并执行操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> selenium &lt;span style="color:#f92672">import&lt;/span> webdriver
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> selenium.webdriver.common.by &lt;span style="color:#f92672">import&lt;/span> By
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> selenium.webdriver.common.keys &lt;span style="color:#f92672">import&lt;/span> Keys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 设置 WebDriver 路径（如果 WebDriver 不在 PATH 中）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>driver &lt;span style="color:#f92672">=&lt;/span> webdriver&lt;span style="color:#f92672">.&lt;/span>Chrome(executable_path&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/path/to/chromedriver&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 打开网页&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>driver&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#e6db74">&amp;#39;https://www.google.com&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查找搜索框元素&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>search_box &lt;span style="color:#f92672">=&lt;/span> driver&lt;span style="color:#f92672">.&lt;/span>find_element(By&lt;span style="color:#f92672">.&lt;/span>NAME, &lt;span style="color:#e6db74">&amp;#39;q&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 向搜索框输入文本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>search_box&lt;span style="color:#f92672">.&lt;/span>send_keys(&lt;span style="color:#e6db74">&amp;#39;Selenium&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 模拟按下 Enter 键&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>search_box&lt;span style="color:#f92672">.&lt;/span>send_keys(Keys&lt;span style="color:#f92672">.&lt;/span>RETURN)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 等待一段时间，等待页面加载完成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>driver&lt;span style="color:#f92672">.&lt;/span>implicitly_wait(&lt;span style="color:#ae81ff">5&lt;/span>) &lt;span style="color:#75715e"># 等待最多 5 秒&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取页面标题并打印&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(driver&lt;span style="color:#f92672">.&lt;/span>title)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 关闭浏览器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>driver&lt;span style="color:#f92672">.&lt;/span>quit()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="常用操作">常用操作&lt;/h1>
&lt;ol>
&lt;li>查找元素&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>find_element(By.ID, 'id')&lt;/code>：通过 ID 查找元素&lt;/li>
&lt;li>&lt;code>find_element(By.NAME, 'name')&lt;/code>：通过名称查找元素&lt;/li>
&lt;li>&lt;code>find_element(By.CLASS_NAME, 'class')&lt;/code>：通过类名查找元素&lt;/li>
&lt;li>&lt;code>find_element(By.XPATH, 'xpath')&lt;/code>：通过 XPath 查找元素&lt;/li>
&lt;li>&lt;code>find_element(By.CSS_SELECTOR, 'css_selector')&lt;/code>：通过 CSS 选择器查找元素&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>元素操作&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>send_keys('text')&lt;/code>：向输入框中输入文本&lt;/li>
&lt;li>&lt;code>click()&lt;/code>：点击元素&lt;/li>
&lt;li>&lt;code>clear()&lt;/code>：清除输入框中的文本&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>等待&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>driver.implicitly_wait(seconds)&lt;/code>：隐式等待，查找元素时如果没有立即找到，会等待指定的时间后再抛出异常。&lt;/li>
&lt;li>&lt;code>WebDriverWait(driver, timeout).until(condition)&lt;/code>：显式等待，直到某个条件成立。&lt;/li>
&lt;/ul>
&lt;h1 id="处理弹窗和切换窗口">处理弹窗和切换窗口&lt;/h1>
&lt;h2 id="处理-javascript-弹窗">处理 JavaScript 弹窗&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>alert &lt;span style="color:#f92672">=&lt;/span> driver&lt;span style="color:#f92672">.&lt;/span>switch_to&lt;span style="color:#f92672">.&lt;/span>alert
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alert&lt;span style="color:#f92672">.&lt;/span>accept() &lt;span style="color:#75715e"># 接受弹窗&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alert&lt;span style="color:#f92672">.&lt;/span>dismiss() &lt;span style="color:#75715e"># 关闭弹窗&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="切换窗口">切换窗口&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取所有窗口句柄&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>windows &lt;span style="color:#f92672">=&lt;/span> driver&lt;span style="color:#f92672">.&lt;/span>window_handles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 切换到新的窗口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>driver&lt;span style="color:#f92672">.&lt;/span>switch_to&lt;span style="color:#f92672">.&lt;/span>window(windows[&lt;span style="color:#ae81ff">1&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 切换回原来的窗口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>driver&lt;span style="color:#f92672">.&lt;/span>switch_to&lt;span style="color:#f92672">.&lt;/span>window(windows[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="使用-headless-模式">使用 Headless 模式&lt;/h1>
&lt;p>Selenium 可以在不显示浏览器窗口的情况下运行，这被称为无头模式（Headless Mode）。对于大多数任务，尤其是爬虫，使用无头模式非常有用。&lt;/p></description></item><item><title>Playwright的使用</title><link>https://merthon.github.io/posts/playwright%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 12 Jan 2025 09:23:25 +0800</pubDate><guid>https://merthon.github.io/posts/playwright%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>安装 Playwright&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>pip install playwright
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装 Playwright 后，还需要下载浏览器的依赖：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>playwright install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="启动浏览器">启动浏览器&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> playwright.sync_api &lt;span style="color:#f92672">import&lt;/span> sync_playwright
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">with&lt;/span> sync_playwright() &lt;span style="color:#66d9ef">as&lt;/span> p:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 启动 Chromium 浏览器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> browser &lt;span style="color:#f92672">=&lt;/span> p&lt;span style="color:#f92672">.&lt;/span>chromium&lt;span style="color:#f92672">.&lt;/span>launch(headless&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>) &lt;span style="color:#75715e"># headless=False 表示显示浏览器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> page &lt;span style="color:#f92672">=&lt;/span> browser&lt;span style="color:#f92672">.&lt;/span>new_page()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 访问网页&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> page&lt;span style="color:#f92672">.&lt;/span>goto(&lt;span style="color:#e6db74">&amp;#39;https://example.com&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 截图保存到文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> page&lt;span style="color:#f92672">.&lt;/span>screenshot(path&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;example.png&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 关闭浏览器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> browser&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="与页面交互">与页面交互&lt;/h1>
&lt;p>Playwright 提供了许多方法来模拟用户的浏览器操作，如点击、填写表单、获取文本等。&lt;/p>
&lt;h2 id="点击按钮">点击按钮&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>page&lt;span style="color:#f92672">.&lt;/span>click(&lt;span style="color:#e6db74">&amp;#39;button#submit&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># 点击指定的按钮&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="填写表单">填写表单&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>page&lt;span style="color:#f92672">.&lt;/span>fill(&lt;span style="color:#e6db74">&amp;#39;input[name=&amp;#34;username&amp;#34;]&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;myUsername&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># 填写用户名字段&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取文本">获取文本&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>text &lt;span style="color:#f92672">=&lt;/span> page&lt;span style="color:#f92672">.&lt;/span>text_content(&lt;span style="color:#e6db74">&amp;#39;h1&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># 获取 &amp;lt;h1&amp;gt; 标签中的文本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(text)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="截图">截图&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>page&lt;span style="color:#f92672">.&lt;/span>screenshot(path&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;screenshot.png&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># 截取页面截图并保存为文件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="等待元素加载">等待元素加载&lt;/h1>
&lt;p>在页面加载或交互时，可能需要等待某个元素出现，可以使用 &lt;code>wait_for_selector&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>page&lt;span style="color:#f92672">.&lt;/span>wait_for_selector(&lt;span style="color:#e6db74">&amp;#39;div#content&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># 等待页面中出现指定的元素&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="使用异步版本">使用异步版本&lt;/h1>
&lt;p>Playwright 提供了同步和异步两种 API。上面展示的是同步 API，你也可以使用异步 API 来执行相同的操作，下面是使用异步方式的示例：&lt;/p></description></item><item><title>爬虫中代理的使用</title><link>https://merthon.github.io/posts/%E7%88%AC%E8%99%AB%E4%B8%AD%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 12 Jan 2025 02:08:30 +0800</pubDate><guid>https://merthon.github.io/posts/%E7%88%AC%E8%99%AB%E4%B8%AD%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>在爬虫中使用代理是为了应对一些网站的反爬虫机制，它能够帮助你隐藏爬虫的真实 IP 地址，避免被封禁。&lt;/p>
&lt;h1 id="代理的基本概念">代理的基本概念&lt;/h1>
&lt;p>代理服务器是一个中间服务器，它接受客户端的请求并代表客户端访问目标网站。通过代理，客户端的 IP 地址对目标服务器来说是代理服务器的 IP 地址，而不是爬虫的真实 IP。
常见的代理类型：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>HTTP 代理&lt;/strong>：适用于普通的 HTTP 请求。&lt;/li>
&lt;li>&lt;strong>HTTPS 代理&lt;/strong>：适用于 HTTPS 请求，提供加密传输。&lt;/li>
&lt;li>&lt;strong>SOCKS 代理&lt;/strong>：支持更多的协议类型，比 HTTP/HTTPS 代理更通用。&lt;/li>
&lt;li>&lt;strong>透明代理&lt;/strong>：代理服务器不会修改请求或响应，目标服务器能看到真实的请求信息。&lt;/li>
&lt;li>&lt;strong>匿名代理&lt;/strong>：代理服务器隐藏了客户端的 IP 地址，但目标服务器知道请求来自代理服务器。&lt;/li>
&lt;li>&lt;strong>高匿代理&lt;/strong>：代理服务器不仅隐藏了客户端的 IP 地址，还不会暴露自己是代理服务器。&lt;/li>
&lt;/ul>
&lt;h1 id="代理池">代理池&lt;/h1>
&lt;p>为了提高爬虫的稳定性，通常会使用代理池，即预先准备一个代理 IP 列表，爬虫在运行时会从池中随机选取代理进行请求。这样，即便某个代理 IP 被封禁，爬虫仍然能够继续工作。
常见的代理池策略：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>随机选择&lt;/strong>：每次请求时从代理池中随机选择一个代理。&lt;/li>
&lt;li>&lt;strong>按频率限制使用&lt;/strong>：一些代理池会根据 IP 的使用频率进行调度，避免频繁使用同一个代理 IP。&lt;/li>
&lt;li>&lt;strong>代理检查&lt;/strong>：定期检查代理是否可用，剔除掉失效的代理。&lt;/li>
&lt;/ul>
&lt;h1 id="设置代理">设置代理&lt;/h1>
&lt;ol>
&lt;li>在 Python 爬虫中使用代理通常依赖于请求库（如 &lt;code>requests&lt;/code>）或 Scrapy 框架。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> requests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>proxies &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;http&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;http://username:password@proxy_ip:proxy_port&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;https&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://username:password@proxy_ip:proxy_port&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> requests&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#e6db74">&amp;#39;http://example.com&amp;#39;&lt;/span>, proxies&lt;span style="color:#f92672">=&lt;/span>proxies)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>text)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>使用 Scrapy 设置代理：
在 Scrapy 中，你可以通过中间件来设置代理。Scrapy 提供了 &lt;code>HttpProxyMiddleware&lt;/code> 来处理代理设置。
&lt;strong>启用代理中间件&lt;/strong>：
在 &lt;code>settings.py&lt;/code> 中启用中间件：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>DOWNLOADER_MIDDLEWARES &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&amp;#39;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>设置代理&lt;/strong>：
可以通过设置 &lt;code>http_proxy&lt;/code> 来指定全局代理，或者在 &lt;code>spider&lt;/code> 里为特定请求设置代理。&lt;/p></description></item><item><title>Parsel库使用</title><link>https://merthon.github.io/posts/parsel%E5%BA%93%E4%BD%BF%E7%94%A8/</link><pubDate>Fri, 10 Jan 2025 11:23:25 +0800</pubDate><guid>https://merthon.github.io/posts/parsel%E5%BA%93%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>&lt;code>parsel&lt;/code> 是一个 Python 库，主要用于 HTML 和 XML 数据的解析，特别适用于 Web 爬虫的开发。它基于 &lt;code>lxml&lt;/code> 和 &lt;code>cssselect&lt;/code>，支持 CSS 选择器和 XPath 查询来提取网页数据。下面是一些基本的使用方法：&lt;/p>
&lt;h3 id="基本用法">基本用法&lt;/h3>
&lt;p>&lt;strong>从 HTML 字符串中提取数据&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> parsel &lt;span style="color:#f92672">import&lt;/span> Selector
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>html &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;lt;html&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;My Page&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;body&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;h1&amp;gt;Welcome to My Page&amp;lt;/h1&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;p class=&amp;#34;description&amp;#34;&amp;gt;This is a test page.&amp;lt;/p&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;/body&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;lt;/html&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>selector &lt;span style="color:#f92672">=&lt;/span> Selector(text&lt;span style="color:#f92672">=&lt;/span>html)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用 CSS 选择器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title &lt;span style="color:#f92672">=&lt;/span> selector&lt;span style="color:#f92672">.&lt;/span>css(&lt;span style="color:#e6db74">&amp;#39;title::text&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>get() &lt;span style="color:#75715e"># 获取 &amp;lt;title&amp;gt;标签的文本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(title) &lt;span style="color:#75715e"># 输出：My Page&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用 XPath 选择器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>description &lt;span style="color:#f92672">=&lt;/span> selector&lt;span style="color:#f92672">.&lt;/span>xpath(&lt;span style="color:#e6db74">&amp;#39;//p[@class=&amp;#34;description&amp;#34;]/text()&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>get()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(description) &lt;span style="color:#75715e"># 输出：This is a test page.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>从网页文件中提取数据&lt;/strong> 如果你有一个 HTML 文件，想要提取其中的数据，可以这样做：&lt;/p></description></item><item><title>基于Session和Cookie的模拟登录</title><link>https://merthon.github.io/posts/%E5%9F%BA%E4%BA%8Esession%E5%92%8Ccookie%E7%9A%84%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</link><pubDate>Thu, 09 Jan 2025 22:15:35 +0800</pubDate><guid>https://merthon.github.io/posts/%E5%9F%BA%E4%BA%8Esession%E5%92%8Ccookie%E7%9A%84%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</guid><description>&lt;h1 id="原理">原理&lt;/h1>
&lt;p>通过浏览器登录某个网站时，服务器会创建一个 &lt;strong>Session&lt;/strong>，并通过 &lt;strong>Cookie&lt;/strong> 存储在客户端（即浏览器）中。每当你访问网站时，浏览器会自动将这些 Cookie 包含在请求中，告知服务器你是一个已经登录的用户，从而获得相应的权限。
在爬虫中模拟登录时，我们需要使用 &lt;code>requests.Session()&lt;/code> 来维护会话（Session），并通过 &lt;code>requests.Session().cookies&lt;/code> 来保存和使用 Cookie，以便后续请求能够模拟登录后的行为。&lt;/p>
&lt;h1 id="步骤">步骤&lt;/h1>
&lt;ol>
&lt;li>发送 GET 请求获取登录页面
我们需要发送 GET 请求获取登录页面。这是为了获取可能包含的隐藏字段（如 CSRF token）以及初始的 Cookie。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> requests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 登录页面的 URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;https://example.com/login&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建一个会话对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>session &lt;span style="color:#f92672">=&lt;/span> requests&lt;span style="color:#f92672">.&lt;/span>Session()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 发送 GET 请求获取登录页面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>get(login_url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 打印返回的 HTML 内容，查看页面结构，特别是是否有 CSRF token 等&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>text)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>解析页面中的隐藏字段（例如 CSRF token）
多网站会使用 CSRF token 来防止跨站请求伪造，登录请求中必须包含正确的 CSRF token。我们需要从登录页面中提取这个 token。&lt;/li>
&lt;/ol>
&lt;p>这里使用 &lt;code>BeautifulSoup&lt;/code> 来解析 HTML 页面并提取隐藏字段。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> bs4 &lt;span style="color:#f92672">import&lt;/span> BeautifulSoup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 解析 HTML 页面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>soup &lt;span style="color:#f92672">=&lt;/span> BeautifulSoup(response&lt;span style="color:#f92672">.&lt;/span>text, &lt;span style="color:#e6db74">&amp;#39;html.parser&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 假设 CSRF token 存储在一个名为 csrf_token 的 input 标签中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>csrf_token &lt;span style="color:#f92672">=&lt;/span> soup&lt;span style="color:#f92672">.&lt;/span>find(&lt;span style="color:#e6db74">&amp;#39;input&amp;#39;&lt;/span>, {&lt;span style="color:#e6db74">&amp;#39;name&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;csrf_token&amp;#39;&lt;/span>})[&lt;span style="color:#e6db74">&amp;#39;value&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>构建登录请求的表单数据
我们已经从页面中获取到了 CSRF token，现在我们可以构造一个包含用户名、密码和 CSRF token 的字典作为表单数据。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 构造登录表单数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_data &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;username&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;your_username&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;password&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;your_password&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;csrf_token&amp;#39;&lt;/span>: csrf_token, &lt;span style="color:#75715e"># 包含 CSRF token&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>发送 POST 请求提交登录表单
使用 &lt;code>requests.Session()&lt;/code> 提交 POST 请求登录，并使用 &lt;code>session&lt;/code> 对象保持会话，以便后续请求能够带上登录状态。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 发送 POST 请求进行登录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_response &lt;span style="color:#f92672">=&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>post(login_url, data&lt;span style="color:#f92672">=&lt;/span>login_data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 检查登录是否成功&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> login_response&lt;span style="color:#f92672">.&lt;/span>ok:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;登录成功&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;登录失败&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>访问需要身份认证的页面
登录成功后，我们就可以使用 &lt;code>session&lt;/code> 对象继续发送请求，访问需要登录权限的页面。由于 &lt;code>session&lt;/code> 会自动管理 Cookie，所有后续请求会自动带上登录信息（如 &lt;code>session_id&lt;/code>）。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 登录成功后访问受保护的页面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>protected_url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;https://example.com/protected_page&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>protected_page &lt;span style="color:#f92672">=&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>get(protected_url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 打印受保护页面的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(protected_page&lt;span style="color:#f92672">.&lt;/span>text)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="demo">demo&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> requests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> bs4 &lt;span style="color:#f92672">import&lt;/span> BeautifulSoup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 登录页面 URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;https://example.com/login&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 受保护页面 URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>protected_url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;https://example.com/protected_page&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建一个会话对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>session &lt;span style="color:#f92672">=&lt;/span> requests&lt;span style="color:#f92672">.&lt;/span>Session()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 发送 GET 请求获取登录页面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>get(login_url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>ok:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;无法访问登录页面&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 解析页面，提取 CSRF token&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>soup &lt;span style="color:#f92672">=&lt;/span> BeautifulSoup(response&lt;span style="color:#f92672">.&lt;/span>text, &lt;span style="color:#e6db74">&amp;#39;html.parser&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>csrf_token &lt;span style="color:#f92672">=&lt;/span> soup&lt;span style="color:#f92672">.&lt;/span>find(&lt;span style="color:#e6db74">&amp;#39;input&amp;#39;&lt;/span>, {&lt;span style="color:#e6db74">&amp;#39;name&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;csrf_token&amp;#39;&lt;/span>})[&lt;span style="color:#e6db74">&amp;#39;value&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 构造登录表单数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_data &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;username&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;your_username&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;password&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;your_password&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;csrf_token&amp;#39;&lt;/span>: csrf_token,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 发送 POST 请求进行登录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_response &lt;span style="color:#f92672">=&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>post(login_url, data&lt;span style="color:#f92672">=&lt;/span>login_data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> login_response&lt;span style="color:#f92672">.&lt;/span>ok:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;登录成功&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;登录失败&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 登录成功后，访问受保护页面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>protected_page &lt;span style="color:#f92672">=&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>get(protected_url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> protected_page&lt;span style="color:#f92672">.&lt;/span>ok:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;成功访问受保护的页面&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(protected_page&lt;span style="color:#f92672">.&lt;/span>text)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;访问受保护页面失败&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>模拟登录</title><link>https://merthon.github.io/posts/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</link><pubDate>Thu, 09 Jan 2025 14:22:35 +0800</pubDate><guid>https://merthon.github.io/posts/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</guid><description>&lt;h1 id="基本原理">基本原理&lt;/h1>
&lt;p>通过模拟用户在浏览器中执行的登录操作，获取并维持用户的登录状态，从而访问需要身份认证的网页或数据。&lt;/p>
&lt;h2 id="发送登录请求">发送登录请求&lt;/h2>
&lt;p>用户在浏览器中提交登录表单时，会向服务器发送一个 HTTP 请求，这个请求通常是一个 &lt;strong>POST&lt;/strong> 请求，包含了用户输入的 &lt;strong>用户名&lt;/strong> 和 &lt;strong>密码&lt;/strong>，以及其他一些必要的字段（例如：CSRF token、验证码等）。&lt;/p>
&lt;h2 id="认证与验证">认证与验证&lt;/h2>
&lt;p>服务器收到登录请求后，会进行认证与验证，主要包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>检查用户名和密码是否正确&lt;/strong>：服务器会对比数据库中的用户数据，验证用户名和密码是否匹配。&lt;/li>
&lt;li>&lt;strong>CSRF token 检查&lt;/strong>：如果存在 CSRF 防护，服务器会验证请求中包含的 CSRF token 是否有效。这个 token 是防止跨站请求伪造攻击的标记。&lt;/li>
&lt;/ul>
&lt;h2 id="设置-cookie-或-token">设置 Cookie 或 Token&lt;/h2>
&lt;p>如果登录信息正确，服务器会在响应中设置一个 &lt;strong>Session cookie&lt;/strong> 或者返回一个 &lt;strong>JWT（JSON Web Token）&lt;/strong>。这些都是用来表示用户身份的认证信息。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Session cookie&lt;/strong>：通常在服务器端生成一个 session ID，并通过 cookie 返回给客户端。该 session ID 用于标识用户的会话，服务器会将会话信息（如用户身份）保存在内存或数据库中。&lt;/li>
&lt;li>&lt;strong>JWT&lt;/strong>：在某些情况下，服务器会返回一个 JWT，客户端需要在后续请求中带上这个 token，来证明自己已经登录。&lt;/li>
&lt;/ul>
&lt;h2 id="维护登录状态">维护登录状态&lt;/h2>
&lt;p>登录成功后，为了模拟用户持续登录的状态，爬虫需要维护登录过程中获取到的 &lt;strong>Session&lt;/strong> 或 &lt;strong>Cookie&lt;/strong>。通过在后续的 HTTP 请求中附带这些认证信息，爬虫可以继续访问需要登录权限的页面。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>保持会话（Session）&lt;/strong>：通过 HTTP 请求中的 &lt;strong>Cookie&lt;/strong>，爬虫可以维持与服务器的会话，这样就可以重复使用相同的登录状态进行多次请求。&lt;/li>
&lt;li>&lt;strong>使用 Token&lt;/strong>：如果使用的是 JWT 等 token 认证方式，爬虫则需要在后续请求的 &lt;strong>Authorization header&lt;/strong> 中附带 token。&lt;/li>
&lt;/ul>
&lt;h2 id="访问受保护的资源">访问受保护的资源&lt;/h2>
&lt;p>登录成功后，用户通常会被重定向到一个主页或其他受保护的页面。此时，爬虫只需要带上保存的 &lt;strong>Cookie&lt;/strong> 或 &lt;strong>Token&lt;/strong>，就可以访问这些页面。&lt;/p></description></item><item><title>基于JWT的模拟登录</title><link>https://merthon.github.io/posts/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</link><pubDate>Thu, 09 Jan 2025 02:15:35 +0800</pubDate><guid>https://merthon.github.io/posts/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</guid><description>&lt;p>&lt;strong>JWT（JSON Web Token）&lt;/strong> 的模拟登录通常用于无状态认证系统，尤其是在 RESTful API 和现代 web 应用中，广泛用于替代传统的基于 Session 的身份验证机制。JWT 是一种轻量级的认证机制，通常由服务器在用户登录时生成，并作为认证凭据返回给客户端。客户端通过存储和发送 JWT 来进行后续的身份验证。&lt;/p>
&lt;h1 id="jwt-的基本原理">JWT 的基本原理&lt;/h1>
&lt;p>WT 是由三部分组成的：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Header&lt;/strong>：指定 JWT 的类型（通常是 JWT）以及签名算法（如 HS256）。&lt;/li>
&lt;li>&lt;strong>Payload&lt;/strong>：包含声明（Claims），通常包括用户的基本信息（如 &lt;code>user_id&lt;/code>）和过期时间（&lt;code>exp&lt;/code>）。这些信息是未加密的，可以被任何人读取，但不能篡改。&lt;/li>
&lt;li>&lt;strong>Signature&lt;/strong>：使用密钥对 Header 和 Payload 进行签名，以防止数据被篡改。&lt;/li>
&lt;/ol>
&lt;h4 id="wt-工作流程">WT 工作流程：&lt;/h4>
&lt;ol>
&lt;li>用户使用用户名和密码发送请求进行登录。&lt;/li>
&lt;li>服务器验证用户信息后，生成一个包含用户信息的 JWT，并返回给客户端。&lt;/li>
&lt;li>客户端将 JWT 存储在本地（通常存储在 &lt;code>localStorage&lt;/code> 或 &lt;code>sessionStorage&lt;/code> 中，或者作为 HTTP cookie）。&lt;/li>
&lt;li>客户端在后续请求中将 JWT 放入请求头中，以便服务器验证该请求是否来自已认证的用户。&lt;/li>
&lt;/ol>
&lt;h1 id="基于-jwt-的模拟登录实现步骤">基于 JWT 的模拟登录实现步骤&lt;/h1>
&lt;p>主要步骤包括：&lt;/p>
&lt;ul>
&lt;li>向登录接口发送用户名和密码请求。&lt;/li>
&lt;li>服务器验证成功后返回 JWT。&lt;/li>
&lt;li>将 JWT 存储并用于后续请求中的身份验证。&lt;/li>
&lt;/ul>
&lt;h2 id="发送-post-请求获取-jwt">发送 POST 请求获取 JWT&lt;/h2>
&lt;p>首先，向服务器的登录 API 发送 POST 请求，提交用户名和密码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> requests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 登录接口 URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;https://example.com/api/login&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 用户名和密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>login_data &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;username&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;your_username&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;password&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;your_password&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 发送 POST 请求进行登录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> requests&lt;span style="color:#f92672">.&lt;/span>post(login_url, json&lt;span style="color:#f92672">=&lt;/span>login_data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 检查登录是否成功&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>ok:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 解析返回的 JSON 响应，提取 JWT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> token &lt;span style="color:#f92672">=&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>json()&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#e6db74">&amp;#39;token&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;登录成功，获取到的 JWT:&amp;#34;&lt;/span>, token)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;登录失败&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-jwt-访问受保护的资源">使用 JWT 访问受保护的资源&lt;/h2>
&lt;p>一旦获取到 JWT，下一步是将其用于后续的身份验证。在每个请求中，JWT 会被放置在请求头的 &lt;code>Authorization&lt;/code> 字段中。&lt;/p></description></item><item><title>BeautifulSoup使用</title><link>https://merthon.github.io/posts/beautifulsoup%E4%BD%BF%E7%94%A8/</link><pubDate>Tue, 07 Jan 2025 12:20:12 +0800</pubDate><guid>https://merthon.github.io/posts/beautifulsoup%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>&lt;code>BeautifulSoup&lt;/code> 是一个非常流行的 Python 库，用于从 HTML 或 XML 文档中提取数据。它常用于网页爬取（web scraping）项目中，特别是在处理不规则的网页结构时，具有很好的灵活性。它可以与 &lt;code>requests&lt;/code> 或 &lt;code>urllib&lt;/code> 配合使用来获取网页内容，然后用来解析和提取所需的数据。
基本用法
导入库并下载网页内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> requests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> bs4 &lt;span style="color:#f92672">import&lt;/span> BeautifulSoup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取网页内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;http://example.com&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> requests&lt;span style="color:#f92672">.&lt;/span>get(url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 BeautifulSoup 对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>soup &lt;span style="color:#f92672">=&lt;/span> BeautifulSoup(response&lt;span style="color:#f92672">.&lt;/span>content, &lt;span style="color:#e6db74">&amp;#39;html.parser&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查找元素：
1.通过标签名查找:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取第一个 &amp;lt;a&amp;gt; 标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a_tag &lt;span style="color:#f92672">=&lt;/span> soup&lt;span style="color:#f92672">.&lt;/span>find(&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(a_tag)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2.&lt;strong>通过类名查找&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取具有特定 class 的标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>div_tag &lt;span style="color:#f92672">=&lt;/span> soup&lt;span style="color:#f92672">.&lt;/span>find(&lt;span style="color:#e6db74">&amp;#39;div&amp;#39;&lt;/span>, class_&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;class-name&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(div_tag)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>3.&lt;strong>通过 id 查找&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取 id 为 specific-id 的标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>element &lt;span style="color:#f92672">=&lt;/span> soup&lt;span style="color:#f92672">.&lt;/span>find(id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;specific-id&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(element)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查找多个元素：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取所有 &amp;lt;a&amp;gt; 标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>all_a_tags &lt;span style="color:#f92672">=&lt;/span> soup&lt;span style="color:#f92672">.&lt;/span>find_all(&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> tag &lt;span style="color:#f92672">in&lt;/span> all_a_tags:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(tag)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取标签的属性：&lt;/p></description></item><item><title>Urllib库的使用</title><link>https://merthon.github.io/posts/urllib%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Tue, 07 Jan 2025 10:10:26 +0800</pubDate><guid>https://merthon.github.io/posts/urllib%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;h3 id="1-urllib-库的基本模块">1. &lt;code>urllib&lt;/code> 库的基本模块&lt;/h3>
&lt;p>&lt;code>urllib&lt;/code> 是 Python 标准库中用于处理 URL（Uniform Resource Locator）的模块，它提供了一系列功能来访问、解析、以及操作 URL。常见的用途包括发起 HTTP 请求、解析 URL、编码和解码查询字符串等。
&lt;code>urllib&lt;/code> 库包含几个子模块，每个子模块提供不同的功能：&lt;/p>
&lt;ul>
&lt;li>&lt;code>urllib.request&lt;/code>：用于打开和读取 URLs（发起 HTTP 请求）。&lt;/li>
&lt;li>&lt;code>urllib.parse&lt;/code>：用于解析 URL。&lt;/li>
&lt;li>&lt;code>urllib.error&lt;/code>：包含与请求相关的异常类。&lt;/li>
&lt;li>&lt;code>urllib.robotparser&lt;/code>：用于解析 robots.txt 文件，确定网站允许哪些爬虫访问。&lt;/li>
&lt;/ul>
&lt;h3 id="2-主要功能">2. 主要功能&lt;/h3>
&lt;h4 id="21-发送-http-请求-urllibrequest">2.1 发送 HTTP 请求 (&lt;code>urllib.request&lt;/code>)&lt;/h4>
&lt;p>可以使用 &lt;code>urllib.request&lt;/code> 模块来发送 GET 或 POST 请求。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GET 请求&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> urllib.request
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;https://www.example.com&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> urllib&lt;span style="color:#f92672">.&lt;/span>request&lt;span style="color:#f92672">.&lt;/span>urlopen(url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>html &lt;span style="color:#f92672">=&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>read()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(html&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>POST 请求&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> urllib.request
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> urllib.parse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;https://www.example.com/login&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>data &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#39;username&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;user&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;password&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;pass&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>data &lt;span style="color:#f92672">=&lt;/span> urllib&lt;span style="color:#f92672">.&lt;/span>parse&lt;span style="color:#f92672">.&lt;/span>urlencode(data)&lt;span style="color:#f92672">.&lt;/span>encode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>request &lt;span style="color:#f92672">=&lt;/span> urllib&lt;span style="color:#f92672">.&lt;/span>request&lt;span style="color:#f92672">.&lt;/span>Request(url, data&lt;span style="color:#f92672">=&lt;/span>data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> urllib&lt;span style="color:#f92672">.&lt;/span>request&lt;span style="color:#f92672">.&lt;/span>urlopen(request)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>html &lt;span style="color:#f92672">=&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>read()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(html&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="22-url-编码与解码-urllibparse">2.2 URL 编码与解码 (&lt;code>urllib.parse&lt;/code>)&lt;/h4>
&lt;p>URL 编码是指将特殊字符（如空格、中文等）转换为适合 URL 使用的格式。&lt;/p></description></item><item><title>Requests库的使用</title><link>https://merthon.github.io/posts/requests%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 06 Jan 2025 10:10:26 +0800</pubDate><guid>https://merthon.github.io/posts/requests%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>&lt;code>requests&lt;/code> 是 Python 中最流行的 HTTP 请求库之一，简化了 HTTP 请求的发送和响应处理。&lt;/p>
&lt;h3 id="1-发送-get-请求">1. 发送 GET 请求&lt;/h3>
&lt;p>&lt;code>requests.get()&lt;/code> 用于发送 GET 请求。它从指定的 URL 获取数据。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> requests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> requests&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#e6db74">&amp;#39;https://httpbin.org/get&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取响应内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>text)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取 JSON 数据（如果有）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>json())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看响应状态码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>status_code)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看响应头&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>headers)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-发送-post-请求">2. 发送 POST 请求&lt;/h3>
&lt;p>&lt;code>requests.post()&lt;/code> 用于发送 POST 请求，通常用于向服务器提交数据。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> requests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>data &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#39;key&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;value&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> requests&lt;span style="color:#f92672">.&lt;/span>post(&lt;span style="color:#e6db74">&amp;#39;https://httpbin.org/post&amp;#39;&lt;/span>, data&lt;span style="color:#f92672">=&lt;/span>data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>text)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以通过 &lt;code>json&lt;/code> 参数发送 JSON 数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> requests
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>json_data &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#39;name&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;John&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;age&amp;#39;&lt;/span>: &lt;span style="color:#ae81ff">30&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> requests&lt;span style="color:#f92672">.&lt;/span>post(&lt;span style="color:#e6db74">&amp;#39;https://httpbin.org/post&amp;#39;&lt;/span>, json&lt;span style="color:#f92672">=&lt;/span>json_data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>text)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-添加请求头">3. 添加请求头&lt;/h3>
&lt;p>有时需要传递特定的请求头（比如 User-Agent 或 Authorization 等）。可以通过 &lt;code>headers&lt;/code> 参数传递自定义的头信息。&lt;/p></description></item><item><title>Httpx库的使用</title><link>https://merthon.github.io/posts/httpx%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 05 Jan 2025 10:10:26 +0800</pubDate><guid>https://merthon.github.io/posts/httpx%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>&lt;code>httpx&lt;/code> 是一个用于 Python 的高性能 HTTP 客户端库，支持异步操作，是 &lt;code>requests&lt;/code> 的现代替代品，功能更强大，特别适合处理异步任务和 HTTP/2。&lt;/p>
&lt;h3 id="基本用法">&lt;strong>基本用法&lt;/strong>&lt;/h3>
&lt;h4 id="1-同步请求">&lt;strong>1. 同步请求&lt;/strong>&lt;/h4>
&lt;p>&lt;code>httpx&lt;/code> 的用法类似 &lt;code>requests&lt;/code>，可以轻松发起同步 HTTP 请求。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> httpx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> httpx&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#e6db74">&amp;#39;https://jsonplaceholder.typicode.com/posts/1&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>status_code) &lt;span style="color:#75715e"># 状态码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(response&lt;span style="color:#f92672">.&lt;/span>json()) &lt;span style="color:#75715e"># 返回 JSON 数据&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>支持的基本方法：&lt;/p>
&lt;ul>
&lt;li>&lt;code>httpx.get(url, ...)&lt;/code>&lt;/li>
&lt;li>&lt;code>httpx.post(url, ...)&lt;/code>&lt;/li>
&lt;li>&lt;code>httpx.put(url, ...)&lt;/code>&lt;/li>
&lt;li>&lt;code>httpx.delete(url, ...)&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="2-异步请求">&lt;strong>2. 异步请求&lt;/strong>&lt;/h4>
&lt;p>&lt;code>httpx&lt;/code> 支持异步操作，通过 &lt;code>async&lt;/code> 和 &lt;code>await&lt;/code> 发起请求。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> httpx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> asyncio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fetch_data&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> httpx&lt;span style="color:#f92672">.&lt;/span>AsyncClient() &lt;span style="color:#66d9ef">as&lt;/span> client:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> client&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#e6db74">&amp;#39;https://jsonplaceholder.typicode.com/posts/1&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(response&lt;span style="color:#f92672">.&lt;/span>json())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>asyncio&lt;span style="color:#f92672">.&lt;/span>run(fetch_data())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="高级用法">&lt;strong>高级用法&lt;/strong>&lt;/h3>
&lt;h4 id="1-设置超时">&lt;strong>1. 设置超时&lt;/strong>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> httpx&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#e6db74">&amp;#39;https://example.com&amp;#39;&lt;/span>, timeout&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10.0&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2.设置自定义 Headers&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>headers &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#39;User-Agent&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;MyApp/1.0&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>response &lt;span style="color:#f92672">=&lt;/span> httpx&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#e6db74">&amp;#39;https://example.com&amp;#39;&lt;/span>, headers&lt;span style="color:#f92672">=&lt;/span>headers)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>3.发送 JSON 数据&lt;/p></description></item><item><title>爬虫基础</title><link>https://merthon.github.io/posts/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 04 Jan 2025 09:14:26 +0800</pubDate><guid>https://merthon.github.io/posts/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="1-uri和url">1. URI和URL&lt;/h1>
&lt;p>URI：全称Uniform Resource Identifier，即统一资源标志符；
URL：Uniform Resource Locator，即统一资源定位符。
URL基本组成格式：&lt;/p>
&lt;pre tabindex="0">&lt;code>scheme://[username:password@]hostname[:port][/path][;parameters][?query][fragment]
&lt;/code>&lt;/pre>&lt;p>scheme：协议。常用的协议有http、https、Ftp等，另外schcme也被常称作protocol。
usemame、password：用户名和密码。
hostname：主机地址。可以是域名或IP地址。
port：端口。服务器设定的端口。
path：路径。用来指定访问某个资源时的附加信息。
query：查询。用来查询某些资源。
fragment:片段。对资源描述的部分补充。&lt;/p>
&lt;h1 id="2http-and-https">2.HTTP and HTTPS&lt;/h1>
&lt;p>HTTP为超文本传输协议，作用是把超文本数据从网络传输到本地测览器，能够保证高效而准确地传输超文本文档。
HTTPS是以安全为目标的HTTP通道，换句话说，就是HTTP的安全版，即在HTTP下加人SSL层
HTTPS工作大概流程：&lt;/p>
&lt;ul>
&lt;li>客户端发起请求，服务器返回公钥证书。&lt;/li>
&lt;li>客户端验证证书的合法性。&lt;/li>
&lt;li>使用公钥加密生成一个会话密钥。&lt;/li>
&lt;li>双方使用该会话密钥加密和解密数据。&lt;/li>
&lt;/ul>
&lt;h2 id="21http请求过程">2.1HTTP请求过程&lt;/h2>
&lt;p>HTTP 请求通常由以下几个部分组成：&lt;/p>
&lt;h3 id="211-请求方法">2.1.1 请求方法&lt;/h3>
&lt;p>HTTP 提供了多种请求方法，每种方法的语义不同。常见的请求方法有：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GET&lt;/strong>：请求指定的资源，通常用于获取数据。&lt;/li>
&lt;li>&lt;strong>POST&lt;/strong>：向服务器发送数据，通常用于提交表单或上传文件。&lt;/li>
&lt;li>&lt;strong>PUT&lt;/strong>：上传指定资源的完整替换版本。&lt;/li>
&lt;li>&lt;strong>DELETE&lt;/strong>：删除指定资源。&lt;/li>
&lt;li>&lt;strong>PATCH&lt;/strong>：部分更新资源。&lt;/li>
&lt;li>&lt;strong>HEAD&lt;/strong>：请求服务器返回响应头部，通常用于检查资源是否存在。&lt;/li>
&lt;li>&lt;strong>OPTIONS&lt;/strong>：询问服务器支持哪些 HTTP 方法。&lt;/li>
&lt;/ul>
&lt;h3 id="212-请求网址request-url">2.1.2 请求网址（Request URL）&lt;/h3>
&lt;p>请求的 URL 指定了要访问的资源的位置，包含了协议、主机、路径、查询参数等信息。&lt;/p>
&lt;h3 id="213-请求头request-headers">2.1.3 请求头（Request Headers）&lt;/h3>
&lt;p>请求头部提供了关于客户端、请求和数据的额外信息。常见的请求头包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Host&lt;/strong>：指定目标主机的域名。&lt;/li>
&lt;li>&lt;strong>User-Agent&lt;/strong>：客户端软件的标识。&lt;/li>
&lt;li>&lt;strong>Accept&lt;/strong>：告知服务器客户端能够处理的数据类型，如 &lt;code>text/html&lt;/code>、&lt;code>application/json&lt;/code>。&lt;/li>
&lt;li>&lt;strong>Content-Type&lt;/strong>：请求体的类型，如 &lt;code>application/json&lt;/code>、&lt;code>application/x-www-form-urlencoded&lt;/code>。&lt;/li>
&lt;li>&lt;strong>Authorization&lt;/strong>：包含身份验证信息，如 Basic 或 Bearer Token。&lt;/li>
&lt;li>&lt;strong>Cookie&lt;/strong>：客户端存储的 Cookies，通常用于会话管理。&lt;/li>
&lt;/ul>
&lt;h3 id="214-请求体request-body">2.1.4 请求体（Request Body）&lt;/h3>
&lt;p>请求体包含请求的具体数据，例如表单数据或上传的文件。对于 &lt;code>POST&lt;/code>、&lt;code>PUT&lt;/code> 等方法，通常需要有请求体。&lt;/p></description></item></channel></rss>