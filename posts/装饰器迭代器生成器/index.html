<!doctype html><html lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:17.5px}</style><title>装饰器，迭代器，生成器</title>
<meta name=description content="装饰器（Decorator 什么是装饰器？ 装饰器是一种设计模式，它允许你在不修改函数或方法代码的前提下，动态地扩展函数或方法的功能。装饰器本质上是一个函数，它接收另一个函数作为参数，并返回一个新的函数，这个新函数包含了原函数的功能，并且可能添加了一些额外的行为。 装饰器常用于：
函数增强：在不改变函数体的情况下，给函 …"><meta name=keywords content='blog,hugo,Python'><meta property="og:url" content="http://localhost:1313/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8/"><meta property="og:type" content="website"><meta property="og:title" content="装饰器，迭代器，生成器"><meta property="og:description" content="装饰器（Decorator 什么是装饰器？ 装饰器是一种设计模式，它允许你在不修改函数或方法代码的前提下，动态地扩展函数或方法的功能。装饰器本质上是一个函数，它接收另一个函数作为参数，并返回一个新的函数，这个新函数包含了原函数的功能，并且可能添加了一些额外的行为。 装饰器常用于：
函数增强：在不改变函数体的情况下，给函 …"><meta property="og:image" content="http://localhost:1313/images/cat.webp"><meta property="og:image:secure_url" content="http://localhost:1313/images/cat.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="装饰器，迭代器，生成器"><meta name=twitter:description content="装饰器（Decorator 什么是装饰器？ 装饰器是一种设计模式，它允许你在不修改函数或方法代码的前提下，动态地扩展函数或方法的功能。装饰器本质上是一个函数，它接收另一个函数作为参数，并返回一个新的函数，这个新函数包含了原函数的功能，并且可能添加了一些额外的行为。 装饰器常用于：
函数增强：在不改变函数体的情况下，给函 …"><meta property="twitter:domain" content="http://localhost:1313/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8/"><meta property="twitter:url" content="http://localhost:1313/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8/"><meta name=twitter:image content="http://localhost:1313/images/cat.webp"><link rel=canonical href=http://localhost:1313/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.275fedb6f364c8865658bae576d82b514ace973f6a13ed63503a85b20c697453.js integrity="sha256-J1/ttvNkyIZWWLrldtgrUUrOlz9qE+1jUDqFsgxpdFM="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=http://localhost:1313/><img src=/images/cat.webp alt=cat></a></div><div class=nav-title><a class=nav-brand href=http://localhost:1313/>Merthon</a></div><div class=nav-links><div class=nav-link><a href=http://localhost:1313/ aria-label><span data-feather=home></span> Home</a></div><div class=nav-link><a href=http://localhost:1313/posts/ aria-label><span data-feather=book></span> Posts</a></div><div class=nav-link><a href=http://localhost:1313/projects/ aria-label><span data-feather=code></span> Projects</a></div><div class=nav-link><a href=http://localhost:1313/tags/ aria-label><span data-feather=tag></span> Tags</a></div><div class=nav-link><a href=https://github.com/Merthon aria-label=github><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=http://localhost:1313/><span data-feather=home></span> Home</a></li><li class=nav-item><a href=http://localhost:1313/posts/><span data-feather=book></span> Posts</a></li><li class=nav-item><a href=http://localhost:1313/projects/><span data-feather=code></span> Projects</a></li><li class=nav-item><a href=http://localhost:1313/tags/><span data-feather=tag></span> Tags</a></li><li class=nav-item><a href=https://github.com/Merthon><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>装饰器，迭代器，生成器</h1><small role=doc-subtitle></small><p class=post-date>January 14, 2025
| Updated January 14, 2025</p><ul class=post-tags><li class=post-tag><a href=http://localhost:1313/tags/python>Python</a></li></ul></div><div class=post-content><h1 id=装饰器decorator>装饰器（Decorator</h1><h2 id=什么是装饰器>什么是装饰器？</h2><p>装饰器是一种设计模式，它允许你在不修改函数或方法代码的前提下，动态地扩展函数或方法的功能。装饰器本质上是一个函数，它接收另一个函数作为参数，并返回一个新的函数，这个新函数包含了原函数的功能，并且可能添加了一些额外的行为。
装饰器常用于：</p><ul><li><strong>函数增强</strong>：在不改变函数体的情况下，给函数添加额外的功能（如日志、验证等）。</li><li><strong>代码复用</strong>：将某些公共的功能（例如权限检查、缓存）提取出来并应用到多个函数。</li></ul><h2 id=工作原理>工作原理</h2><p>装饰器的工作方式是通过<strong>闭包</strong>。一个装饰器通常会返回一个封装原函数的新函数，这个新函数会在原函数执行前或执行后插入一些额外的操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 定义一个装饰器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decorator</span>(func):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wrapper</span>():
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Before function call&#34;</span>)
</span></span><span style=display:flex><span>        func()
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;After function call&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> wrapper
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 应用装饰器</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@decorator</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>say_hello</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Hello, World!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 调用装饰后的函数</span>
</span></span><span style=display:flex><span>say_hello()
</span></span></code></pre></div><h2 id=工作过程><strong>工作过程：</strong></h2><ol><li><code>@decorator</code> 语法是装饰器的简写，相当于 <code>say_hello = decorator(say_hello)</code>。</li><li>当我们调用 <code>say_hello()</code> 时，实际调用的是装饰器返回的 <code>wrapper</code> 函数。</li><li><code>wrapper</code> 函数在调用原始的 <code>say_hello()</code> 函数之前和之后分别添加了额外的操作。</li></ol><h2 id=装饰器常见用法>装饰器常见用法：</h2><ul><li><strong>日志记录</strong>：在函数执行前后记录日志。</li><li><strong>权限控制</strong>：检查当前用户是否有权限执行某个操作。</li><li><strong>性能监控</strong>：测量函数的执行时间。</li></ul><h1 id=迭代器iterator>迭代器（Iterator）</h1><h2 id=什么是迭代器>什么是迭代器？</h2><p>迭代器是一个对象，它遵循 <strong>迭代协议</strong>，可以逐个访问集合中的元素。要成为一个迭代器，必须实现以下两个方法：</p><ul><li><code>__iter__()</code>：返回自身的迭代器对象。</li><li><code>__next__()</code>：返回集合中的下一个元素，如果没有元素了，就抛出 <code>StopIteration</code> 异常。</li></ul><h2 id=工作原理-1>工作原理</h2><p>迭代器的核心是 <code>__next__()</code> 方法，它每次调用时会返回集合中的下一个元素，直到没有元素可以返回为止。</p><p>在 Python 中，所有的可迭代对象（例如列表、元组、字典等）都隐式地实现了 <code>__iter__()</code> 方法，支持迭代。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyIterator</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, start, end):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>current <span style=color:#f92672>=</span> start
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>end <span style=color:#f92672>=</span> end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __iter__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __next__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>current <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>end:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>StopIteration</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>current <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>current <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建迭代器对象</span>
</span></span><span style=display:flex><span>my_iter <span style=color:#f92672>=</span> MyIterator(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用 for 循环遍历迭代器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> my_iter:
</span></span><span style=display:flex><span>    print(num)
</span></span></code></pre></div><p><strong>工作过程：</strong></p><ol><li><code>__iter__()</code> 返回当前对象本身，表示该对象是可迭代的。</li><li><code>__next__()</code> 每次调用返回下一个数字，当 <code>self.current > self.end</code> 时抛出 <code>StopIteration</code>，表示迭代完成。</li></ol><h4 id=迭代器与可迭代对象的区别>迭代器与可迭代对象的区别：</h4><ul><li><strong>可迭代对象（Iterable）</strong>：实现了 <code>__iter__()</code> 方法的对象，可以用 <code>for</code> 循环遍历。</li><li><strong>迭代器（Iterator）</strong>：实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象，支持逐个访问元素。</li></ul><h1 id=生成器generator>生成器（Generator）</h1><h4 id=什么是生成器>什么是生成器？</h4><p>生成器是 Python 中的一种特殊类型的迭代器。生成器函数使用 <code>yield</code> 关键字生成一个迭代器对象。生成器是惰性求值的，只有在你请求一个元素时，它才会生成该元素。
与普通的迭代器不同，生成器函数的调用不会返回所有数据，而是返回一个生成器对象，这个对象会在需要时按需生成数据。</p><h4 id=工作原理-2>工作原理</h4><p>生成器函数定义时与普通函数类似，但在返回数据时使用 <code>yield</code> 关键字而不是 <code>return</code>。</p><ul><li><code>yield</code> 每次返回一个值，并暂停函数的执行，保存当前状态。</li><li>下一次调用生成器时，从上次 <code>yield</code> 的地方继续执行。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_generator</span>(start, end):
</span></span><span style=display:flex><span>    current <span style=color:#f92672>=</span> start
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> current <span style=color:#f92672>&lt;=</span> end:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> current  <span style=color:#75715e># 暂停并返回当前值</span>
</span></span><span style=display:flex><span>        current <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建生成器对象</span>
</span></span><span style=display:flex><span>gen <span style=color:#f92672>=</span> my_generator(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用 for 循环遍历生成器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> gen:
</span></span><span style=display:flex><span>    print(num)
</span></span></code></pre></div><p><strong>工作过程：</strong></p><ol><li><code>yield current</code> 每次返回一个值，并暂停函数的执行。</li><li>生成器对象 <code>gen</code> 是惰性生成的，直到 <code>for</code> 循环需要数据时才会生成并返回。</li><li>每次调用 <code>next()</code> 时，从 <code>yield</code> 暂停的地方继续执行。</li></ol><h4 id=生成器的优势>生成器的优势：</h4><ul><li><strong>节省内存</strong>：生成器是惰性求值的，它不会将所有数据一次性加载到内存中。</li><li><strong>性能优越</strong>：生成器在处理大量数据时可以节省大量内存，因为数据是在需要时生成的。</li></ul><h4 id=生成器与普通函数的区别>生成器与普通函数的区别：</h4><ul><li><strong>普通函数</strong>：返回的是一个值或对象，函数调用后会立即返回结果。</li><li><strong>生成器函数</strong>：使用 <code>yield</code> 返回生成的值，函数会暂停，直到再次调用时从暂停的位置继续执行。</li></ul></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div><aside class=post-toc><nav id=toc><nav id=TableOfContents><ul><li><a href=#装饰器decorator>装饰器（Decorator</a><ul><li><a href=#什么是装饰器>什么是装饰器？</a></li><li><a href=#工作原理>工作原理</a></li><li><a href=#工作过程><strong>工作过程：</strong></a></li><li><a href=#装饰器常见用法>装饰器常见用法：</a></li></ul></li><li><a href=#迭代器iterator>迭代器（Iterator）</a><ul><li><a href=#什么是迭代器>什么是迭代器？</a></li><li><a href=#工作原理-1>工作原理</a><ul><li></li></ul></li></ul></li><li><a href=#生成器generator>生成器（Generator）</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></nav></aside></main><footer class=footer><span>&copy; 2025 Merthon</span>
<span>Made with &#10084;&#65039; Hugo</span></footer></body></html>