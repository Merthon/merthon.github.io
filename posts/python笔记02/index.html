<!doctype html><html lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:17.5px}</style><title>Python笔记02</title>
<meta name=description content="流程控制 if-else Python 中的 if else 语句可以细分为三种形式，分别是 if 语句、if else 语句和 if elif else 语句 对语法格式的说明：
“表达式”可以是一个单一的值或者变量，也可以是由运算符组成的复杂语句，形式不限，只要它能得到一个值就行。不管“表达式”的结果是什么类 …"><meta name=keywords content='blog,hugo,Python,笔记'><meta property="og:url" content="http://localhost:1313/posts/python%E7%AC%94%E8%AE%B002/"><meta property="og:type" content="website"><meta property="og:title" content="Python笔记02"><meta property="og:description" content="流程控制 if-else Python 中的 if else 语句可以细分为三种形式，分别是 if 语句、if else 语句和 if elif else 语句 对语法格式的说明：
“表达式”可以是一个单一的值或者变量，也可以是由运算符组成的复杂语句，形式不限，只要它能得到一个值就行。不管“表达式”的结果是什么类 …"><meta property="og:image" content="http://localhost:1313/images/cat.webp"><meta property="og:image:secure_url" content="http://localhost:1313/images/cat.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Python笔记02"><meta name=twitter:description content="流程控制 if-else Python 中的 if else 语句可以细分为三种形式，分别是 if 语句、if else 语句和 if elif else 语句 对语法格式的说明：
“表达式”可以是一个单一的值或者变量，也可以是由运算符组成的复杂语句，形式不限，只要它能得到一个值就行。不管“表达式”的结果是什么类 …"><meta property="twitter:domain" content="http://localhost:1313/posts/python%E7%AC%94%E8%AE%B002/"><meta property="twitter:url" content="http://localhost:1313/posts/python%E7%AC%94%E8%AE%B002/"><meta name=twitter:image content="http://localhost:1313/images/cat.webp"><link rel=canonical href=http://localhost:1313/posts/python%E7%AC%94%E8%AE%B002/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.275fedb6f364c8865658bae576d82b514ace973f6a13ed63503a85b20c697453.js integrity="sha256-J1/ttvNkyIZWWLrldtgrUUrOlz9qE+1jUDqFsgxpdFM="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=http://localhost:1313/><img src=/images/cat.webp alt=cat></a></div><div class=nav-title><a class=nav-brand href=http://localhost:1313/>Merthon</a></div><div class=nav-links><div class=nav-link><a href=http://localhost:1313/ aria-label><span data-feather=home></span> Home</a></div><div class=nav-link><a href=http://localhost:1313/posts/ aria-label><span data-feather=book></span> Posts</a></div><div class=nav-link><a href=http://localhost:1313/projects/ aria-label><span data-feather=code></span> Projects</a></div><div class=nav-link><a href=http://localhost:1313/tags/ aria-label><span data-feather=tag></span> Tags</a></div><div class=nav-link><a href=https://github.com/Merthon aria-label=github><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=http://localhost:1313/><span data-feather=home></span> Home</a></li><li class=nav-item><a href=http://localhost:1313/posts/><span data-feather=book></span> Posts</a></li><li class=nav-item><a href=http://localhost:1313/projects/><span data-feather=code></span> Projects</a></li><li class=nav-item><a href=http://localhost:1313/tags/><span data-feather=tag></span> Tags</a></li><li class=nav-item><a href=https://github.com/Merthon><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>Python笔记02</h1><small role=doc-subtitle></small><p class=post-date>December 27, 2024</p><ul class=post-tags><li class=post-tag><a href=http://localhost:1313/tags/python>Python</a></li><li class=post-tag><a href=http://localhost:1313/tags/%E7%AC%94%E8%AE%B0>笔记</a></li></ul></div><div class=post-content><h1 id=流程控制>流程控制</h1><h2 id=if-else>if-else</h2><p>Python 中的 if else 语句可以细分为三种形式，分别是 if 语句、if else 语句和 if elif else 语句
对语法格式的说明：</p><ul><li>“表达式”可以是一个单一的值或者变量，也可以是由运算符组成的复杂语句，形式不限，只要它能得到一个值就行。不管“表达式”的结果是什么类型，if else 都能判断它是否成立（真或者假）。</li><li>“代码块”由具由相同缩进量的若干条语句组成。</li><li>if、elif、else 语句的最后都有冒号<code>:</code>，不要忘记。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>age <span style=color:#f92672>=</span> int( input(<span style=color:#e6db74>&#34;请输入你的年龄：&#34;</span>) )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> age <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>18</span> :
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;你还未成年，建议在家人陪同下使用该软件！&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;如果你已经得到了家长的同意，请忽略以上提示。&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#该语句不属于if的代码块</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;软件正在使用中...&#34;</span>)
</span></span></code></pre></div><h3 id=判断表达式是否成立>判断表达式是否成立</h3><p>if 和 elif 后面的“表达式”的形式是很自由的，只要表达式有一个结果，不管这个结果是什么类型，Python 都能判断它是“真”还是“假”。</p><h3 id=对缩进的要求>对缩进的要求</h3><p>pyhton是以缩进来标记代码块的，代码块一定要有缩进，没有缩进的不是代码块。另外，同一个代码块的缩进量要相同，缩进量不同的不属于同一个代码块。</p><h2 id=pass语句及其作用>pass语句及其作用</h2><p> Python 提供了一种更加专业的做法，就是空语句 pass。<strong>pass</strong> 是 Python 中的关键字，用来让解释器跳过此处，什么都不做。</p><h2 id=assert断言函数及用法>assert断言函数及用法</h2><p>assert 语句，又称断言语句，可以看做是功能缩小版的 if 语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误。</p><h2 id=while循环>while循环</h2><p>while 循环和 if 条件分支语句类似，即在条件（表达式）为真的情况下，会执行相应的代码块。不同之处在于，只要条件为真，while 就会一直重复执行那段代码块。</p><h2 id=for循环>for循环</h2><p>它常用于遍历字符串、列表、元组、字典、集合等序列类型，逐个获取序列中的各个元素。<br>for 循环的语法格式如下：<br>for 迭代变量 in 字符串|列表|元组|字典|集合：<br>    代码块
格式中，迭代变量用于存放从序列类型变量中读取出来的元素，所以一般不会在循环中对迭代变量手动赋值；代码块指的是具有相同缩进格式的多行代码（和 while 一样），由于和循环结构联用，因此代码块又称为循环体。</p><h2 id=else用法>else用法</h2><p>无论是 while 循环还是 for 循环，其后都可以紧跟着一个 else 代码块，它的作用是当循环条件为 False 跳出循环时，程序会最先执行 else 代码块中的代码。</p><h2 id=循环嵌套>循环嵌套</h2><p>支持 if 语句相互嵌套，while 和 for 循环结构也支持嵌套。所谓嵌套（Nest），就是一条语句里面还有另一条语句，例如 for 里面还有 for，while 里面还有 while，甚至 while 中有 for 或者 for 中有 while 也都是允许的。<br>当 2 个（甚至多个）循环结构相互嵌套时，位于外层的循环结构常简称为外层循环或外循环，位于内层的循环结构常简称为内层循环或内循环。<br>循环嵌套结构的代码，Python 解释器执行的流程为：</p><ol><li>当外层循环条件为 True 时，则执行外层循环结构中的循环体；</li><li>外层循环体中包含了普通程序和内循环，当内层循环的循环条件为 True 时会执行此循环中的循环体，直到内层循环条件为 False，跳出内循环；</li><li>如果此时外层循环的条件仍为 True，则返回第 2 步，继续执行外层循环体，直到外层循环的循环条件为 False；</li><li>当内层循环的循环条件为 False，且外层循环的循环条件也为 False，则整个嵌套循环才算执行完毕。</li></ol><h2 id=break>break</h2><p>break 语句可以立即终止当前循环的执行，跳出当前所在的循环结构。无论是 while 循环还是 for 循环，只要执行 break 语句，就会直接结束当前正在执行的循环体。</p><h2 id=continue的用法>continue的用法</h2><p>continue 语句的作用则没有那么强大，它只会终止执行本次循环中剩下的代码，直接从下一次循环继续执行。</p><h1 id=函数>函数</h1><p>Python 提供了一个功能，即允许我们将常用的代码以固定的格式封装（包装）成一个独立的模块，只要知道这个模块的名字就可以重复使用它，这个模块就叫做函数（Function）。
函数的本质就是一段有特定功能、可以重复使用的代码</p><h2 id=函数的定义>函数的定义</h2><p>也就是创建一个函数，可以理解为创建一个具有某些用途的工具。定义函数需要用 def 关键字实现，具体的语法格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>函数名</span>(参数列表):  
</span></span><span style=display:flex><span>    <span style=color:#f92672>//</span>实现特定功能的多行代码  
</span></span><span style=display:flex><span>    [<span style=color:#66d9ef>return</span> [返回值]]
</span></span></code></pre></div><p>其中，用 [] 括起来的为可选择部分，即可以使用，也可以省略。<br>此格式中，各部分参数的含义如下：</p><ul><li>函数名：其实就是一个符合 Python 语法的标识符，但不建议读者使用 a、b、c 这类简单的标识符作为函数名，函数名最好能够体现出该函数的功能（如上面的 my_len，即表示我们自定义的 len() 函数）。</li><li>形参列表：设置该函数可以接收多少个参数，多个参数之间用逗号（ , ）分隔。</li><li>[return [返回值] ]：整体作为函数的可选参参数，用于设置该函数的返回值。也就是说，一个函数，可以用返回值，也可以没有返回值，是否需要根据实际情况而定。</li></ul><h2 id=函数的调用>函数的调用</h2><p>调用函数也就是执行函数。如果把创建的函数理解为一个具有某种用途的工具，那么调用函数就相当于使用该工具。<br>函数调用的基本语法格式如下所示：
<code>[返回值] = 函数名([形参值])</code>
其中，函数名即指的是要调用的函数的名称；形参值指的是当初创建函数时要求传入的各个形参的值。如果该函数有返回值，我们可以通过一个变量来接收该值，当然也可以不接受。</p><h2 id=函数值传递和引用传递包括形式参数和实际参数的区别>函数值传递和引用传递（包括形式参数和实际参数的区别）</h2><p>通常情况下，定义函数时都会选择有参数的函数形式，函数参数的作用是传递数据给函数，令其对接收的数据做具体的操作处理。<br>在使用函数时，经常会用到形式参数（简称“形参”）和实际参数（简称“实参”），二者都叫参数，之间的区别是：</p><ul><li>形式参数：在定义函数时，函数名后面括号中的参数就是形式参数，例如:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#定义函数时，这里的函数参数 obj 就是形式参数</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>demo</span>(obj)
</span></span><span style=display:flex><span>  print(obj)
</span></span></code></pre></div><ul><li>实际参数：在调用函数时，函数名后面括号中的参数称为实际参数，也就是函数的调用者给函数的参数。例如:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;helloworld&#34;</span>
</span></span><span style=display:flex><span>demo(a)
</span></span></code></pre></div><p>实参和形参的区别，就如同剧本选主角，剧本中的角色相当于形参，而演角色的演员就相当于实参。
想一个问题，那就是实参是如何传递给形参的呢？
根据实际参数的类型不同，函数参数的传递方式可分为 2 种，分别为值传递和引用（地址）传递：</p><ol><li>值传递：适用于实参类型为不可变类型（字符串、数字、元组）；</li><li>引用（地址）传递：适用于实参类型为可变类型（列表，字典）；
值传递和引用传递的区别是，函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；而函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。</li></ol><h2 id=函数默认参数>函数默认参数</h2><p>在调用函数时如果不指定某个参数，Python 解释器会抛出异常。为了解决这个问题，Python 允许为参数设置默认值，即在定义函数时，直接给形式参数指定一个默认值。这样的话，即便调用函数时没有给拥有默认值的形参传递参数，该参数可以直接使用定义函数时设置的默认值。<br>Python 定义带有默认值参数的函数，其语法格式如下：
def 函数名(&mldr;，形参名，形参名=默认值)：<br>    代码块
注意，在使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误。</p><h1 id=变量作用域全局变量和局部变量>变量作用域（全局变量和局部变量）</h1><p>所谓作用域（Scope），就是变量的有效范围，就是变量可以在哪个范围以内使用。有些变量可以在整段代码的任意位置使用，有些变量只能在函数内部使用，有些变量只能在 for 循环内部使用。<br>变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。本节我们只讲解两种变量，局部变量和全局变量。</p><h2 id=局部变量>局部变量</h2><p>在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable）。<br>要知道，当函数被执行时，Python 会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。</p><h2 id=全局变量>全局变量</h2><p>Python 还允许在所有函数的外部定义变量，这样的变量称为全局变量（Global Variable）。<br>和局部变量不同，全局变量的默认作用域是整个程序，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。</p><h3 id=定义全局变量的方法>定义全局变量的方法</h3><p>在函数体外定义的变量，一定是全局变量。
在函数体内定义全局变量。即使用 global 关键字对变量进行修饰后，该变量就会变为全局变量。</p><h1 id=lambda表达式匿名函数及用法>lambda表达式（匿名函数）及用法</h1><p>lambda 表达式，又称匿名函数，常用来表示内部仅包含 1 行表达式的函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。<br>lambda 表达式的语法格式如下：<br><code>name = lambda [list] : 表达式</code>
其中，定义 lambda 表达式，必须使用 lambda 关键字<code>[list]</code> 作为可选参数，等同于定义函数是指定的参数列表；value 为该表达式的名称。
可以这样理解 lambda 表达式，其就是简单函数（函数体仅是单行的表达式）的简写版本。相比函数，lamba 表达式具有以下  2 个优势：</p><ul><li>对于单行函数，使用 lambda 表达式可以省去定义函数的过程，让代码更加简洁；</li><li>对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能。</li></ul><h1 id=类和对象>类和对象</h1><p>面向对象中，常用术语包括：</p><ul><li>类：可以理解是一个模板，通过它可以创建出无数个具体实例。比如，前面编写的 tortoise 表示的只是乌龟这个物种，通过它可以创建出无数个实例来代表各种不同特征的乌龟（这一过程又称为类的实例化）。</li><li>对象：类并不能直接使用，通过类创建出的实例（又称对象）才能使用。这有点像汽车图纸和汽车的关系，图纸本身（类）并不能为人们使用，通过图纸创建出的一辆辆车（对象）才能使用。</li><li>属性：类中的所有变量称为属性。例如，tortoise 这个类中，bodyColor、footNum、weight、hasShell 都是这个类拥有的属性。</li><li>方法：类中的所有函数通常称为方法。不过，和函数所有不同的是，类方法至少要包含一个 self 参数（后续会做详细介绍）。例如，tortoise 类中，crawl()、eat()、sleep()、protect() 都是这个类所拥有的方法，类方法无法单独使用，只能和类的对象一起使用。</li></ul><h2 id=类>类</h2><p>程序中类的使用顺序是这样的：</p><ol><li>创建（定义）类，也就是制作图纸的过程；</li><li>创建类的实例对象（根据图纸造出实际的物品），通过实例对象实现特定的功能。</li></ol><h3 id=定义>定义</h3><p>Python 中定义一个类使用 class 关键字实现，其基本语法格式如下：<br>class 类名：<br>    多个（≥0）类属性&mldr;<br>    多个（≥0）类方法&mldr;
 类属性指的就是包含在类中的变量；而类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称。需要注意的一点是，同属一个类的所有类属性和类方法，要保持统一的缩进格式，通常统一缩进 4 个空格。</p><h3 id=__init__类构造方法><code>__init__()</code>类构造方法</h3><p> 在创建类时，我们可以手动添加一个 <strong>init</strong>() 方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。<br>构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。Python 类中，手动添加构造方法的语法格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> __init__(self,<span style=color:#f92672>...</span>):  
</span></span><span style=display:flex><span>    代码块
</span></span></code></pre></div><h2 id=类对象的创建和使用>类对象的创建和使用</h2><p>创建类对象的过程，又称为类的实例化。
对已定义好的类进行实例化，其语法格式如下：
类名(参数)
定义类时，如果没有手动添加 <code>__init__() </code>构造方法，又或者添加的<code> __init__()</code> 中仅有一个 self 参数，则创建类对象时的参数可以省略不写。</p><h3 id=使用>使用</h3><p>定义的类只有进行实例化，也就是使用该类创建对象之后，才能得到利用。总的来说，实例化后的类对象可以执行以下操作：</p><ul><li>访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量；</li><li>调用类对象的方法，包括调用现有的方法，以及给类对象动态添加方法。</li></ul><h3 id=类对象访问变量或方法>类对象访问变量或方法</h3><p>使用已创建好的类对象访问类中实例变量的语法格式如下：
类对象名.变量名
使用类对象调用类中方法的语法格式如下：
对象名.方法名(参数)
注意，对象名和变量名以及方法名之间用点 &ldquo;.&rdquo; 连接。</p><h3 id=self用法详解>self用法详解</h3><p>定义类的过程中，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将 self 参数作为方法的第一个参数。
总之，无论是类中的构造函数还是普通的类方法，实际调用它们的谁，则第一个参数 self 就代表谁。</p><h3 id=类变量和实例变量类属性和实例属性>类变量和实例变量（类属性和实例属性）</h3><p>在类体中，根据变量定义的位置不同，以及定义的方式不同，类属性又可细分为以下 3 种类型：</p><ol><li>类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；</li><li>类体中，所有函数内部：以“self.变量名”的方式定义的变量，称为实例属性或实例变量；</li><li>类体中，所有函数内部：以“变量名=变量值”的方式定义的变量，称为局部变量。</li></ol><h3 id=property函数定义属性>property()函数：定义属性</h3><p>为了能够有效操作类中的属性，类中应包含读（或写）类属性的多个 getter（或 setter）方法，这样就可以通过“类对象.方法(参数)”的方式操作属性
Python 中提供了 property() 函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性。<br>property() 函数的基本使用格式如下：
<code>属性名=property(fget=None, fset=None, fdel=None, doc=None)</code>
get 参数用于指定获取该属性值的类方法，fset 参数用于指定设置该属性值的方法，fdel 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。</p><h1 id=继承>继承</h1><p>Python 中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）。
子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。语法格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>类名</span>(父类1, 父类2, <span style=color:#f92672>...</span>)<span style=color:#960050;background-color:#1e0010>：</span>  
</span></span><span style=display:flex><span><span style=color:#75715e>#类定义部分</span>
</span></span></code></pre></div><h2 id=父类方法重写>父类方法重写</h2><p>我们可能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，我们就需要在子类中重复父类的方法。</p><h2 id=super函数调用父类的构造方法>super()函数：调用父类的构造方法</h2><p>在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：</p><ol><li>类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；</li><li>使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。</li></ol><h1 id=多态>多态</h1><p>类的多态特性，还要满足以下 2 个前提条件：</p><ol><li>继承：多态一定是发生在子类和父类之间；</li><li>重写：子类重写了父类的方法。
Python 这种由多态衍生出的更灵活的编程机制，又称为“鸭子模型”或“鸭子类型”。</li></ol><h1 id=类特殊成员属性和方法>类特殊成员（属性和方法）</h1><p>凡是以双下划线 <code>__</code>开头和结尾命名的成员（属性和方法），都被称为类的特殊成员（特殊属性和特殊方法）。</p><h1 id=异常处理>异常处理</h1><p>Python 也提供了处理异常的机制，可以让我们捕获并处理这些错误，让程序继续沿着一条不会出错的路径执行。
用<code>try except</code>语句块捕获并处理异常，其基本语法结构如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>try</span>:  
</span></span><span style=display:flex><span>    可能产生异常的代码块  
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> [ (Error1, Error2, <span style=color:#f92672>...</span> ) [<span style=color:#66d9ef>as</span> e] ]:  
</span></span><span style=display:flex><span>    处理异常的代码块1  
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> [ (Error3, Error4, <span style=color:#f92672>...</span> ) [<span style=color:#66d9ef>as</span> e] ]:  
</span></span><span style=display:flex><span>    处理异常的代码块2  
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span>  [<span style=color:#a6e22e>Exception</span>]:  
</span></span><span style=display:flex><span>    处理其它异常
</span></span></code></pre></div><p>从<code>try except</code>的基本语法格式可以看出，try 块有且仅有一个，但 except 代码块可以有多个，且每个 except 块都可以同时处理多种异常。
try except 语句的执行流程如下：</p><ol><li>首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动生成一个异常类型，并将该异常提交给 Python 解释器，此过程称为捕获异常。</li><li>当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。
在原本的<code>try except</code>结构的基础上，Python 异常处理机制还提供了一个 else 块，也就是原有 try except 语句的基础上再添加一个 else 块，即<code>try except else</code>结构。<br>使用 else 包裹的代码，只有当 try 块没有捕获到任何异常时，才会得到执行；反之，如果 try 块捕获到异常，即便调用对应的 except 处理完异常，else 块中的代码也不会得到执行。</li></ol><h3 id=资源回收>资源回收</h3><p>异常处理机制还提供了一个 finally 语句，通常用来为 try 块中的程序做扫尾清理工作
和 else 语句不同，finally 只要求和 try 搭配使用，而至于该结构中是否包含 except 以及 else，对于 finally 不是必须的（else 必须和 try except 搭配使用）。
在整个异常处理机制中，finally 语句的功能是：无论 try 块是否发生异常，最终都要进入 finally 语句，并执行其中的代码块。</p><h3 id=raise用法>raise用法</h3><p>python允许我们在程序中手动设置异常，使用 raise 语句即可。
aise 语句的基本语法格式为：<br><code>raise [exceptionName [(reason)]]</code>
其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。</p></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div><aside class=post-toc><nav id=toc><nav id=TableOfContents><ul><li><a href=#流程控制>流程控制</a><ul><li><a href=#if-else>if-else</a><ul><li><a href=#判断表达式是否成立>判断表达式是否成立</a></li><li><a href=#对缩进的要求>对缩进的要求</a></li></ul></li><li><a href=#pass语句及其作用>pass语句及其作用</a></li><li><a href=#assert断言函数及用法>assert断言函数及用法</a></li><li><a href=#while循环>while循环</a></li><li><a href=#for循环>for循环</a></li><li><a href=#else用法>else用法</a></li><li><a href=#循环嵌套>循环嵌套</a></li><li><a href=#break>break</a></li><li><a href=#continue的用法>continue的用法</a></li></ul></li><li><a href=#函数>函数</a><ul><li><a href=#函数的定义>函数的定义</a></li><li><a href=#函数的调用>函数的调用</a></li><li><a href=#函数值传递和引用传递包括形式参数和实际参数的区别>函数值传递和引用传递（包括形式参数和实际参数的区别）</a></li><li><a href=#函数默认参数>函数默认参数</a></li></ul></li><li><a href=#变量作用域全局变量和局部变量>变量作用域（全局变量和局部变量）</a><ul><li><a href=#局部变量>局部变量</a></li><li><a href=#全局变量>全局变量</a><ul><li><a href=#定义全局变量的方法>定义全局变量的方法</a></li></ul></li></ul></li><li><a href=#lambda表达式匿名函数及用法>lambda表达式（匿名函数）及用法</a></li><li><a href=#类和对象>类和对象</a><ul><li><a href=#类>类</a><ul><li><a href=#定义>定义</a></li><li><a href=#__init__类构造方法><code>__init__()</code>类构造方法</a></li></ul></li><li><a href=#类对象的创建和使用>类对象的创建和使用</a><ul><li><a href=#使用>使用</a></li><li><a href=#类对象访问变量或方法>类对象访问变量或方法</a></li><li><a href=#self用法详解>self用法详解</a></li><li><a href=#类变量和实例变量类属性和实例属性>类变量和实例变量（类属性和实例属性）</a></li><li><a href=#property函数定义属性>property()函数：定义属性</a></li></ul></li></ul></li><li><a href=#继承>继承</a><ul><li><a href=#父类方法重写>父类方法重写</a></li><li><a href=#super函数调用父类的构造方法>super()函数：调用父类的构造方法</a></li></ul></li><li><a href=#多态>多态</a></li><li><a href=#类特殊成员属性和方法>类特殊成员（属性和方法）</a></li><li><a href=#异常处理>异常处理</a><ul><li><ul><li><a href=#资源回收>资源回收</a></li><li><a href=#raise用法>raise用法</a></li></ul></li></ul></li></ul></nav></nav></aside></main><footer class=footer><span>&copy; 2024 Merthon</span>
<span>Made with &#10084;&#65039; Hugo</span></footer></body></html>