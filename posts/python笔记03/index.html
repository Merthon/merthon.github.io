<!doctype html><html lang=en><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:17.5px}</style><title>Python笔记03</title>
<meta name=description content="模块和包 什么是模块？模块化编程 python提供了强大的模块支持，主要体现在，不仅 Python 标准库中包含了大量的模块（称为标准模块），还有大量的第三方模块。 模块就是 Python 程序。换句话说，任何 Python 程序都可以作为模块。 代码的可重用性体现在，当编写好一个模块后，只要编程过程中需要用到该模块中 …"><meta name=keywords content='blog,hugo,Python,笔记'><meta property="og:url" content="http://localhost:1313/posts/python%E7%AC%94%E8%AE%B003/"><meta property="og:type" content="website"><meta property="og:title" content="Python笔记03"><meta property="og:description" content="模块和包 什么是模块？模块化编程 python提供了强大的模块支持，主要体现在，不仅 Python 标准库中包含了大量的模块（称为标准模块），还有大量的第三方模块。 模块就是 Python 程序。换句话说，任何 Python 程序都可以作为模块。 代码的可重用性体现在，当编写好一个模块后，只要编程过程中需要用到该模块中 …"><meta property="og:image" content="http://localhost:1313/images/cat.webp"><meta property="og:image:secure_url" content="http://localhost:1313/images/cat.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Python笔记03"><meta name=twitter:description content="模块和包 什么是模块？模块化编程 python提供了强大的模块支持，主要体现在，不仅 Python 标准库中包含了大量的模块（称为标准模块），还有大量的第三方模块。 模块就是 Python 程序。换句话说，任何 Python 程序都可以作为模块。 代码的可重用性体现在，当编写好一个模块后，只要编程过程中需要用到该模块中 …"><meta property="twitter:domain" content="http://localhost:1313/posts/python%E7%AC%94%E8%AE%B003/"><meta property="twitter:url" content="http://localhost:1313/posts/python%E7%AC%94%E8%AE%B003/"><meta name=twitter:image content="http://localhost:1313/images/cat.webp"><link rel=canonical href=http://localhost:1313/posts/python%E7%AC%94%E8%AE%B003/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.275fedb6f364c8865658bae576d82b514ace973f6a13ed63503a85b20c697453.js integrity="sha256-J1/ttvNkyIZWWLrldtgrUUrOlz9qE+1jUDqFsgxpdFM="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=http://localhost:1313/><img src=/images/cat.webp alt=cat></a></div><div class=nav-title><a class=nav-brand href=http://localhost:1313/>Merthon</a></div><div class=nav-links><div class=nav-link><a href=http://localhost:1313/ aria-label><span data-feather=home></span> Home</a></div><div class=nav-link><a href=http://localhost:1313/posts/ aria-label><span data-feather=book></span> Posts</a></div><div class=nav-link><a href=http://localhost:1313/projects/ aria-label><span data-feather=code></span> Projects</a></div><div class=nav-link><a href=http://localhost:1313/tags/ aria-label><span data-feather=tag></span> Tags</a></div><div class=nav-link><a href=https://github.com/Merthon aria-label=github><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=http://localhost:1313/><span data-feather=home></span> Home</a></li><li class=nav-item><a href=http://localhost:1313/posts/><span data-feather=book></span> Posts</a></li><li class=nav-item><a href=http://localhost:1313/projects/><span data-feather=code></span> Projects</a></li><li class=nav-item><a href=http://localhost:1313/tags/><span data-feather=tag></span> Tags</a></li><li class=nav-item><a href=https://github.com/Merthon><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>Python笔记03</h1><small role=doc-subtitle></small><p class=post-date>December 28, 2024</p><ul class=post-tags><li class=post-tag><a href=http://localhost:1313/tags/python>Python</a></li><li class=post-tag><a href=http://localhost:1313/tags/%E7%AC%94%E8%AE%B0>笔记</a></li></ul></div><div class=post-content><h1 id=模块和包>模块和包</h1><h2 id=什么是模块模块化编程>什么是模块？模块化编程</h2><p>python提供了强大的模块支持，主要体现在，不仅 Python 标准库中包含了大量的模块（称为标准模块），还有大量的第三方模块。
模块就是 Python 程序。换句话说，任何 Python 程序都可以作为模块。
代码的可重用性体现在，当编写好一个模块后，只要编程过程中需要用到该模块中的某个功能（由变量、函数、类实现），无需做重复性的编写工作，直接在程序中导入该模块即可使用该功能。
模块，可以理解为是对代码更高级的封装，即把能够实现某一特定功能的代码编写在同一个 .py 文件中，并将其作为一个独立的模块，这样既可以方便其它程序或脚本导入并使用，同时还能有效避免函数名和变量名发生冲突。
举例：先创建一个hello.py文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>say</span>():
</span></span><span style=display:flex><span>   print(<span style=color:#e6db74>&#39;Hello world&#39;</span>)
</span></span></code></pre></div><p>再在同一目录下创建一个say.py文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 导入刚刚创建好的hello</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> hello
</span></span><span style=display:flex><span>hello<span style=color:#f92672>.</span>say()
</span></span></code></pre></div><p>运行后就是HelloWorld
hello.py 就是一个自定义的模块（有关自定义模块，后续章节会做详细讲解），我们只需要将 hellp.py 模块导入到 say.py 文件中，就可以直接在 say.py 文件中使用模块中的资源。</p><h2 id=导入模块-import用法>导入模块 import用法</h2><p>主要有以下两种：</p><ol><li><code>import 模块名1 [as 别名1], 模块名2 [as 别名2]，…</code>：使用这种语法格式的 import 语句，会导入指定模块中的所有成员（包括变量、函数、类等）。不仅如此，当需要使用模块中的成员时，需用该模块名（或别名）作为前缀，否则 Python 解释器会报错。</li><li><code>from 模块名 import 成员名1 [as 别名1]，成员名2 [as 别名2]，…</code>： 使用这种语法格式的 import 语句，只会导入模块中指定的成员，而不是全部成员。同时，当程序中使用该成员时，无需附加任何前缀，直接使用成员名（或别名）即可。
注意，用 [] 括起来的部分，可以使用，也可以省略。<br>其中，第二种 import 语句也可以导入指定模块中的所有成员，即使用 form 模块名 import ＊，但不推荐。
一般不推荐使用“from 模块 import”这种语法导入指定模块内的所有成员，因为它存在潜在的风险。比如同时导入 module1 和 module2 内的所有成员，假如这两个模块内都有一个 foo() 函数，那么当在程序中执行如下代码时：<br>foo()
上面调用的这个 foo() 函数到底是 module1 模块中的还是 module2 模块中的？因此，这种导入指定模块内所有成员的用法是有风险的。</li></ol><h2 id=包>包</h2><h3 id=创建包>创建包</h3><p>包其实就是文件夹，更确切的说，是一个包含“<strong>init</strong>.py”文件的文件夹。因此，如果我们想手动创建一个包，只需进行以下 2 步操作：</p><ol><li>新建一个文件夹，文件夹的名称就是新建包的包名；</li><li>在该文件夹中，创建一个 <strong>init</strong>.py 文件（前后各有 2 个下划线‘_’），该文件中可以不编写任何代码。当然，也可以编写一些 Python 初始化代码，则当有其它程序文件导入包时，会自动执行该文件中的代码。</li></ol><h3 id=包的导入>包的导入</h3><p>包其实本质上还是模块，因此导入模块的语法同样也适用于导入包。无论导入我们自定义的包，还是导入从他处下载的第三方包，导入方法可归结为以下 3 种：</p><ol><li><code>import 包名[.模块名 [as 别名]]</code></li><li><code>from 包名 import 模块名 [as 别名]</code></li><li><code>from 包名.模块名 import 成员名 [as 别名]</code>
用 [] 括起来的部分，是可选部分，即可以使用，也可以直接忽略。
注意，导入包的同时，会在包目录下生成一个含有 <strong>init</strong>.cpython-36.pyc 文件的 <strong>pycache</strong> 文件夹</li></ol><h1 id=文件操作>文件操作</h1><p>关于文件，它有两个关键属性，分别是“文件名”和“路径”。其中，文件名指的是为每个文件设定的名称，而路径则用来指明文件在计算机上的位置。</p><h2 id=绝对路径与相对路径>绝对路径与相对路径</h2><p>明确一个文件所在的路径，有 2 种表示方式，分别是：</p><ul><li><p>绝对路径：总是从根文件夹开始，Window 系统中以盘符（C：、D：）作为根文件夹，而 OS X 或者 Linux 系统中以 / 作为根文件夹。</p></li><li><p>相对路径：指的是文件相对于当前工作目录所在的位置。例如，当前工作目录为 &ldquo;C:\Windows\System32&rdquo;，若文件 demo.txt 就位于这个 System32 文件夹下，则 demo.txt 的相对路径表示为 &ldquo;.\demo.txt&rdquo;（其中 .\ 就表示当前所在目录）。
在使用相对路径表示某文件所在的位置时，除了经常使用 .\ 表示当前所在目录之外，还会用到 ..\ 表示当前所在目录的父目录。
Python os.path 模块提供了一些函数，可以实现绝对路径和相对路径之间的转换，以及检查给定的路径是否为绝对路径，比如说：</p></li><li><p>调用 os.path.abspath(path) 将返回 path 参数的绝对路径的字符串，这是将相对路径转换为绝对路径的简便方法。</p></li><li><p>调用 os.path.isabs(path)，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False。</p></li><li><p>调用 os.path.relpath(path, start) 将返回从 start 路径到 path 的相对路径的字符串。如果没有提供 start，就使用当前工作目录作为开始路径。</p></li><li><p>调用 os.path.dirname(path) 将返回一个字符串，它包含 path 参数中最后一个斜杠之前的所有内容；调用 os.path.basename(path) 将返回一个字符串，它包含 path 参数中最后一个斜杠之后的所有内容。</p></li></ul><h2 id=文件基本操作>文件基本操作</h2><p>文件的操作有很多种，常见的操作包括创建、删除、修改权限、读取、写入等，这些操作可大致分为以下 2 类：</p><ol><li>删除、修改权限：作用于文件本身，属于系统级操作。</li><li>写入、读取：是文件最常用的操作，作用于文件的内容，属于应用级操作。
文件的应用级操作可以分为以下 3 步，每一步都需要借助对应的函数实现：</li><li>打开文件：使用 open() 函数，该函数会返回一个文件对象；</li><li>对已打开文件做读/写操作：读取文件内容可使用 read()、readline() 以及 readlines() 函数；向文件中写入内容，可以使用 write() 函数。</li><li>关闭文件：完成对文件的读/写操作之后，最后需要关闭文件，可以使用 close() 函数。
一个文件，必须在打开之后才能对其进行操作，并且在操作结束之后，还应该将其关闭，这 3 步的顺序不能打乱。</li></ol><h3 id=open函数详解打开指定文件>open()函数详解：打开指定文件</h3><p>首先需要创建或者打开指定的文件，并创建一个文件对象，而这些工作可以通过内置的 open() 函数实现。<br>open() 函数用于创建或打开指定文件，该函数的常用语法格式如下：<br>file = open(file_name [, mode=&lsquo;r&rsquo; [ , buffering=-1 [ , encoding = None ]]])
此格式中，用 [] 括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：</p><ul><li>file：表示要创建的文件对象。</li><li>file_name：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。</li><li>mode：可选参数，用于指定文件的打开模式。可选的打开模式如表 1 所示。如果不写，则默认以只读（r）模式打开文件。</li><li>buffering：可选参数，用于指定对文件做读写操作时，是否使用缓冲区（本节后续会详细介绍）。</li><li>encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码）。</li></ul><h3 id=read函数按字节字符读取文件>read()函数：按字节（字符）读取文件</h3><p> 3 种函数，它们都可以帮我们实现读取文件中数据的操作：</p><ol><li>read() 函数：逐个字节或者字符读取文件中的内容；</li><li>readline() 函数：逐行读取文件中的内容；</li><li>readlines() 函数：一次性读取文件中多行内容。</li></ol><h3 id=readline和readlines函数按行读取文件>readline()和readlines()函数：按行读取文件</h3><p>和 read() 函数不同，这 2 个函数都以“行”作为读取单位，即每次都读取目标文件中的一行。对于读取以文本格式打开的文件，读取一行很好理解；对于读取以二进制格式打开的文件，它们会以“\n”作为读取一行的标志。</p><h3 id=write和writelines向文件中写入数据>write()和writelines()：向文件中写入数据</h3><p>文件对象提供了 write() 函数，可以向文件中写入指定内容。该函数的语法格式如下：
file.write(string)
其中，file 表示已经打开的文件对象；string 表示要写入文件的字符串（或字节串，仅适用写入二进制文件中）。
如果打开文件模式中包含 w（写入），那么向文件中写入内容时，会先清空原文件中的内容，然后再写入新的内容。</p><h4 id=writelines函数>writelines()函数</h4><p>Python 的文件对象中，不仅提供了 write() 函数，还提供了 writelines() 函数，可以实现将字符串列表写入文件中。
需要注意的是，使用 writelines() 函数向文件中写入多行数据时，不会自动给各行添加换行符。</p><h3 id=close函数关闭文件>close函数关闭文件</h3><p>close() 函数是专门用来关闭已打开文件的，其语法格式也很简单，如下所示：</p><p>file.close()</p><p>其中，file 表示已打开的文件对象。</p></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div><aside class=post-toc><nav id=toc><nav id=TableOfContents><ul><li><a href=#模块和包>模块和包</a><ul><li><a href=#什么是模块模块化编程>什么是模块？模块化编程</a></li><li><a href=#导入模块-import用法>导入模块 import用法</a></li><li><a href=#包>包</a><ul><li><a href=#创建包>创建包</a></li><li><a href=#包的导入>包的导入</a></li></ul></li></ul></li><li><a href=#文件操作>文件操作</a><ul><li><a href=#绝对路径与相对路径>绝对路径与相对路径</a></li><li><a href=#文件基本操作>文件基本操作</a><ul><li><a href=#open函数详解打开指定文件>open()函数详解：打开指定文件</a></li><li><a href=#read函数按字节字符读取文件>read()函数：按字节（字符）读取文件</a></li><li><a href=#readline和readlines函数按行读取文件>readline()和readlines()函数：按行读取文件</a></li><li><a href=#write和writelines向文件中写入数据>write()和writelines()：向文件中写入数据</a></li><li><a href=#close函数关闭文件>close函数关闭文件</a></li></ul></li></ul></li></ul></nav></nav></aside></main><footer class=footer><span>&copy; 2024 Merthon</span>
<span>Made with &#10084;&#65039; Hugo</span></footer></body></html>